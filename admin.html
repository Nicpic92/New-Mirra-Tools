<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Admin - Report Configurations</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        .mapping-table th { width: 30%; }
        .list-group-item h6 { margin-bottom: 0; }
    </style>
</head>
<body>
    <div class="container mt-5 mb-5">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1 class="mb-0">Admin Console</h1>
            <a href="/" class="btn btn-outline-primary">Go to Dashboard</a>
        </div>
        
        <!-- Client Configuration Management -->
        <div class="row g-5">
            <div class="col-12">
                <div class="card">
                     <div class="card-body">
                        <h2 id="formTitle">Client Configurations</h2>
                        <p class="text-muted">Manage settings for individual clients and their column mappings.</p>
                         <div class="row">
                            <div class="col-md-7">
                                <form id="configForm">
                                    <input type="hidden" id="configId">
                                    <h5>Step 1: Basic Information</h5>
                                    <div class="mb-3"><label for="configName" class="form-label">Configuration Name</label><input type="text" class="form-control" id="configName" required></div>
                                    <div class="mb-3"><label for="clientName" class="form-label">Client Name (for PDF Reports)</label><input type="text" class="form-control" id="clientName"></div>
                                    <hr>
                                    <h5>Step 2: Upload to Map Columns</h5>
                                     <div class="mb-3"><label for="reportUploader" class="form-label">Upload XLSX File</label><input class="form-control" type="file" id="reportUploader" accept=".xlsx"></div>
                                    <div id="mappingSection" class="mt-4" style="display: none;">
                                        <h6>Map Your Fields to Detected Headers:</h6>
                                        <table class="table table-bordered table-sm mapping-table">
                                            <thead class="table-light"><tr><th>Standard Field</th><th>Client's Column Header</th></tr></thead>
                                            <tbody id="mappingTableBody"></tbody>
                                        </table>
                                    </div>
                                    <hr>
                                    <button type="submit" class="btn btn-primary">Save Configuration</button>
                                    <button type="button" class="btn btn-secondary" id="clearBtn">Clear Form</button>
                                </form>
                            </div>
                            <div class="col-md-5">
                                <h5>Existing Configurations</h5>
                                <ul class="list-group" id="configList"></ul>
                            </div>
                         </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Global Categorization Rules Section -->
        <div class="row g-5 mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-body">
                        <h2>Global Categorization & Team Management</h2>
                        <p class="text-muted">Manage teams, define categories for each team, and create rules to automatically assign claims.</p>
                        
                        <div class="row">
                            <!-- Team and Category Management -->
                            <div class="col-md-4">
                                <h5>1. Manage Teams</h5>
                                <ul class="list-group mb-3" id="teamList"></ul>
                                <form id="newTeamForm" class="d-flex mb-4">
                                    <input type="text" id="newTeamName" class="form-control me-2" placeholder="New Team Name" required>
                                    <button type="submit" class="btn btn-primary btn-sm">Add Team</button>
                                </form>

                                <h5>2. Manage Categories</h5>
                                <div class="mb-3">
                                    <label for="teamCategorySelect" class="form-label">Select Team</label>
                                    <select class="form-select" id="teamCategorySelect"><option>Select a team to add category to...</option></select>
                                </div>
                                <form id="newCategoryForm" class="d-flex">
                                    <input type="text" id="newCategoryName" class="form-control me-2" placeholder="New Category Name" required>
                                    <button type="submit" class="btn btn-primary btn-sm">Add Category</button>
                                </form>
                                <div id="categoryListContainer" class="mt-3"></div>
                            </div>
                            <!-- Rules Assignment -->
                            <div class="col-md-8">
                                <h5>3. Assign Rules</h5>
                                <p class="small">Upload a report to discover new, uncategorized claim edits and note keywords. Then assign them to a category.</p>
                                <div class="row bg-light p-3 rounded mb-3">
                                    <div class="col-md-6">
                                        <label for="categorizationConfigSelector" class="form-label fw-bold">Select Config to Read Columns</label>
                                        <select class="form-select" id="categorizationConfigSelector"><option>Load configs first...</option></select>
                                    </div>
                                    <div class="col-md-6">
                                        <label for="categorizationReportUploader" class="form-label fw-bold">Upload Report to Find Rules</label>
                                        <input class="form-control" type="file" id="categorizationReportUploader" accept=".xlsx" disabled>
                                    </div>
                                </div>
                                
                                <div id="rulesAssignmentContainer" style="display: none;">
                                    <!-- NEW: Save button at the top -->
                                    <button class="btn btn-success mb-3 save-rules-btn">Save All Rule Assignments</button>

                                    <h6>Uncategorized Claim Edits (Alphabetical)</h6>
                                    <table class="table table-sm table-bordered">
                                        <thead class="table-light"><tr><th>Edit Text</th><th>Assign to Category</th></tr></thead>
                                        <tbody id="uncategorizedEditsTable"></tbody>
                                    </table>
                                    
                                    <!-- UPDATED: Header changed for clarity -->
                                    <h6 class="mt-4">Uncategorized Claim Notes (Alphabetical)</h6>
                                    <table class="table table-sm table-bordered">
                                       <thead class="table-light"><tr><th>Full Note Text</th><th>Assign to Category</th></tr></thead>
                                       <tbody id="uncategorizedNotesTable"></tbody>
                                    </table>

                                    <button class="btn btn-success mt-3 save-rules-btn">Save All Rule Assignments</button>
                                </div>
                                <div id="noRulesFound" class="alert alert-info">Upload a file to begin.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- API ENDPOINTS ---
    const CONFIG_API = '/.netlify/functions/configurations';
    const TEAMS_API = '/.netlify/functions/teams';
    const CATEGORIES_API = '/.netlify/functions/categories';
    const RULES_API = '/.netlify/functions/rules';

    // --- DOM ELEMENTS (condensed for brevity) ---
    const configForm = document.getElementById('configForm'), configIdInput = document.getElementById('configId'), configNameInput = document.getElementById('configName'), clientNameInput = document.getElementById('clientName'), clearBtn = document.getElementById('clearBtn'), reportUploader = document.getElementById('reportUploader'), mappingSection = document.getElementById('mappingSection'), mappingTableBody = document.getElementById('mappingTableBody'), configList = document.getElementById('configList');
    const teamList = document.getElementById('teamList'), newTeamForm = document.getElementById('newTeamForm'), newTeamNameInput = document.getElementById('newTeamName'), teamCategorySelect = document.getElementById('teamCategorySelect'), categoryListContainer = document.getElementById('categoryListContainer'), newCategoryForm = document.getElementById('newCategoryForm'), newCategoryNameInput = document.getElementById('newCategoryName');
    const categorizationConfigSelector = document.getElementById('categorizationConfigSelector'), categorizationReportUploader = document.getElementById('categorizationReportUploader'), rulesAssignmentContainer = document.getElementById('rulesAssignmentContainer'), uncategorizedEditsTable = document.getElementById('uncategorizedEditsTable'), uncategorizedNotesTable = document.getElementById('uncategorizedNotesTable'), noRulesFoundDiv = document.getElementById('noRulesFound');
    
    // --- GLOBAL STATE ---
    let allTeams = [], allCategories = [], detectedHeaders = [], columnMappingsForCategorization = {};
    let existingEditRules = new Map(), existingNoteRules = new Map();
    const standardFields = [ { key: 'claimId', displayName: 'Claim ID / Number', required: true }, { key: 'age', displayName: 'Age (in days)', required: true }, { key: 'netPayment', displayName: 'Net Payment Amount', required: true }, { key: 'state', displayName: 'Claim State', required: true }, { key: 'status', displayName: 'Claim Status', required: true }, { key: 'networkStatus', displayName: 'Network Status', required: true }, { key: 'providerName', displayName: 'Billing Provider Name', required: true }, { key: 'edit', displayName: 'Claim Edits', required: true }, { key: 'notes', displayName: 'Claim Notes', required: true }, { key: 'dsnp', displayName: 'DSNP Status', required: false }, { key: 'totalCharges', displayName: 'Total Billed Amount', required: false }, ];
    
    // --- CORE DATA LOADING ---
    async function loadConfigurations() {
        try {
            const response = await fetch(CONFIG_API);
            const configs = await response.json();
            window.allClientConfigs = configs; 
            configList.innerHTML = configs.length ? '' : '<li class="list-group-item">No configurations found.</li>';
            categorizationConfigSelector.innerHTML = '<option selected disabled value="">Select a configuration...</option>';
            configs.forEach(config => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.textContent = config.config_name;
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-danger btn-sm'; deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => deleteConfig(config.id);
                li.appendChild(deleteBtn);
                configList.appendChild(li);
                categorizationConfigSelector.add(new Option(config.config_name, config.id));
            });
        } catch (error) { console.error('Error loading configurations:', error); }
    }
    
    async function loadTeams() { /* Unchanged from previous version */ }
    async function loadCategories() { /* Unchanged from previous version */ }
    async function loadRules() {
        try {
            const [editRes, noteRes] = await Promise.all([ fetch(`${RULES_API}?type=edit`), fetch(`${RULES_API}?type=note`) ]);
            existingEditRules = new Map((await editRes.json()).map(rule => [rule.text, rule.category_id]));
            existingNoteRules = new Map((await noteRes.json()).map(rule => [rule.text, rule.category_id]));
        } catch (error) { console.error("Failed to load existing rules:", error); }
    }

    async function loadAllData() {
        await Promise.all([loadTeams(), loadCategories(), loadRules(), loadConfigurations()]);
    }

    // --- CLIENT CONFIGURATION LOGIC (Unchanged) ---
    function renderMappingUI() { /* Unchanged */ }
    configForm.addEventListener('submit', async (e) => { /* Unchanged */ });
    async function deleteConfig(id) { /* Unchanged */ }
    reportUploader.addEventListener('change', (event) => { /* Unchanged */ });
    clearBtn.addEventListener('click', () => configForm.reset());

    // --- TEAM & CATEGORY LOGIC ---
    function renderTeamList() { /* Unchanged */ }
    function populateTeamDropdown() { /* Unchanged */ }
    newTeamForm.addEventListener('submit', async (e) => { /* Unchanged */ });
    async function deleteTeam(id) { /* Unchanged */ }
    function renderCategoryList() { /* Unchanged */ }
    newCategoryForm.addEventListener('submit', async (e) => { /* Unchanged, uses helper functions */ });
    async function deleteCategory(id) { /* Unchanged, uses helper functions */ }
    
    // --- RULE MANAGEMENT LOGIC ---
    categorizationConfigSelector.addEventListener('change', () => {
        const selectedId = parseInt(categorizationConfigSelector.value, 10);
        const config = (window.allClientConfigs || []).find(c => c.id === selectedId);
        if (config?.config_data?.columnMappings) {
            columnMappingsForCategorization = config.config_data.columnMappings;
            const hasRequiredCols = columnMappingsForCategorization.edit && columnMappingsForCategorization.notes;
            categorizationReportUploader.disabled = !hasRequiredCols;
            if(!hasRequiredCols) alert('Selected config must map both "Claim Edits" and "Claim Notes".')
        }
    });

    categorizationReportUploader.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const dataJson = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]);
            processUploadedReport(dataJson);
        };
        reader.readAsArrayBuffer(file);
    });

    // *** THIS FUNCTION IS MODIFIED FOR THE FIX ***
    function processUploadedReport(data) {
        const detectedEdits = new Set();
        const detectedNotes = new Set(); // Renamed for clarity
        const { edit: editColumn, notes: notesColumn } = columnMappingsForCategorization;

        data.forEach(row => {
            // Process Claim Edits (unchanged)
            const editValue = row[editColumn];
            if (editValue && !existingEditRules.has(editValue)) {
                detectedEdits.add(editValue);
            }
            
            // Process Claim Notes (NEW LOGIC)
            // Treat the entire note as a single rule
            const noteValue = (row[notesColumn] || '').toString().trim();
            if (noteValue && !existingNoteRules.has(noteValue)) {
                detectedNotes.add(noteValue);
            }
        });

        const sortedEdits = Array.from(detectedEdits).sort((a, b) => a.localeCompare(b));
        const sortedNotes = Array.from(detectedNotes).sort((a, b) => a.localeCompare(b));
        
        uncategorizedEditsTable.innerHTML = '';
        sortedEdits.forEach(text => {
            const row = uncategorizedEditsTable.insertRow();
            row.insertCell().textContent = text;
            row.insertCell().appendChild(createCategoryDropdown());
        });
        
        uncategorizedNotesTable.innerHTML = '';
        sortedNotes.forEach(noteText => {
            const row = uncategorizedNotesTable.insertRow();
            row.insertCell().textContent = noteText;
            row.insertCell().appendChild(createCategoryDropdown());
        });
        
        const hasRules = sortedEdits.length > 0 || sortedNotes.length > 0;
        rulesAssignmentContainer.style.display = hasRules ? 'block' : 'none';
        noRulesFoundDiv.textContent = hasRules ? '' : 'No new, uncategorized items found in the uploaded file.';
        noRulesFoundDiv.style.display = hasRules ? 'none' : 'block';
    }
    
    function createCategoryDropdown() {
        const select = document.createElement('select');
        select.className = 'form-select form-select-sm';
        select.add(new Option('Select category...', ''));
        allCategories.sort((a,b) => (a.team_name || '').localeCompare(b.team_name || '') || a.category_name.localeCompare(b.category_name))
            .forEach(cat => {
                select.add(new Option(`${cat.team_name} -> ${cat.category_name}`, cat.id));
            });
        return select;
    }

    // *** HELPER FUNCTIONS FOR DYNAMIC DROPDOWNS (Unchanged) ***
    function addOptionToAllDropdowns(newCategory) { /* Unchanged from previous version */ }
    function removeOptionFromAllDropdowns(categoryId) { /* Unchanged from previous version */ }

    // *** THIS LISTENER IS MODIFIED FOR THE FIX ***
    function saveRules() {
        const getRulesFromTable = (table) => Array.from(table.rows).map(row => ({
            text: row.cells[0].textContent,
            category_id: row.cells[1].querySelector('select').value
        })).filter(rule => rule.category_id);

        const editRulesToSave = getRulesFromTable(uncategorizedEditsTable);
        const noteRulesToSave = getRulesFromTable(uncategorizedNotesTable);

        Promise.all([
            editRulesToSave.length > 0 ? fetch(`${RULES_API}?type=edit`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(editRulesToSave) }) : Promise.resolve(),
            noteRulesToSave.length > 0 ? fetch(`${RULES_API}?type=note`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(noteRulesToSave) }) : Promise.resolve()
        ]).then(() => {
            if (editRulesToSave.length || noteRulesToSave.length) {
                alert('Rules saved successfully!');
                rulesAssignmentContainer.style.display = 'none';
                noRulesFoundDiv.textContent = 'Upload a file to begin.';
                noRulesFoundDiv.style.display = 'block';
                return loadRules();
            } else {
                alert('No new rules were assigned.');
            }
        }).catch(error => {
            alert(`Failed to save rules: ${error.message}`);
        });
    }

    // Attach listener to both save buttons
    document.querySelectorAll('.save-rules-btn').forEach(btn => {
        btn.addEventListener('click', saveRules);
    });

    // --- INITIAL PAGE LOAD ---
    loadAllData();

    // --- PASTE UNCHANGED FUNCTIONS HERE TO AVOID ERRORS ---
    (function pasteUnchangedFunctions() {
        newTeamForm.addEventListener('submit', async (e) => { e.preventDefault(); const name = newTeamNameInput.value.trim(); if (!name) return; try { await fetch(TEAMS_API, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ team_name: name }) }); newTeamNameInput.value = ''; await loadTeams(); } catch (error) { alert('Failed to add team.'); } });
        async function deleteTeam(id) { if (!confirm('Are you sure?')) return; try { await fetch(`${TEAMS_API}?id=${id}`, { method: 'DELETE' }); await loadAllData(); } catch (error) { alert('Failed to delete team.'); } }
        newCategoryForm.addEventListener('submit', async (e) => { e.preventDefault(); const category_name = newCategoryNameInput.value.trim(); const team_id = parseInt(teamCategorySelect.value, 10); if (!category_name || !team_id) return alert('Please select a team and enter a category name.'); try { const response = await fetch(CATEGORIES_API, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ category_name, team_id }) }); if (!response.ok) throw new Error('Failed'); const newCategory = await response.json(); const team = allTeams.find(t => t.id === team_id); newCategory.team_name = team ? team.team_name : 'Unknown'; allCategories.push(newCategory); renderCategoryList(); addOptionToAllDropdowns(newCategory); newCategoryNameInput.value = ''; } catch (error) { alert('Failed to add category.'); } });
        async function deleteCategory(id) { if (!confirm('Are you sure?')) return; try { const response = await fetch(`${CATEGORIES_API}?id=${id}`, { method: 'DELETE' }); if (!response.ok) throw new Error('Failed'); const index = allCategories.findIndex(cat => cat.id === id); if (index > -1) allCategories.splice(index, 1); renderCategoryList(); removeOptionFromAllDropdowns(id); await loadRules(); } catch (error) { alert('Failed to delete category.'); } }
        function addOptionToAllDropdowns(newCategory) { const allSelects = document.querySelectorAll('#uncategorizedEditsTable select, #uncategorizedNotesTable select'); const newOption = new Option(`${newCategory.team_name} -> ${newCategory.category_name}`, newCategory.id); allSelects.forEach(select => { select.add(newOption.cloneNode(true)); }); allSelects.forEach(select => { Array.from(select.options).sort((a, b) => a.text.localeCompare(b.text)).forEach(option => select.add(option)); }); }
        function removeOptionFromAllDropdowns(categoryId) { const allSelects = document.querySelectorAll('#uncategorizedEditsTable select, #uncategorizedNotesTable select'); allSelects.forEach(select => { const optionToRemove = select.querySelector(`option[value="${categoryId}"]`); if (optionToRemove) optionToRemove.remove(); }); }
    })();
});
</script>
</body>
</html>```

### Step 3: Updated `index.html` (Full Code)

This file contains the updated JavaScript logic to perform an exact match on full claim notes.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Claims Dashboard & Analytics Engine</title>
    <!-- Libraries and CSS (unchanged) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; }
        .dashboard-card { border-left-width: 4px; }
        .metric-value { font-size: 2.25rem; font-weight: 700; }
        #work-queue-table th { background-color: #005A9C; color: white; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container-fluid p-4">
        <!-- Header Section (unchanged) -->
        <header class="mb-4 d-flex justify-content-between align-items-center">
             <div>
                <img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAZCAYAAAC115MjAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARRSURBVChTPZf/a9NXHMc/520kLg3L+m2DIsO2pKGv+i8u/AN2d9FNHHRwdr3sDqYru93VzU5XV7c3o05FmJ2YqW432B/A68qKVgN6KVoLqS11475c7nN/eR5+25f6eRy9Dw79dE/u+RzP53O+z+f+uD/wPz3uA1fC42BxeBQ8DheDh8HDZfD4WIKzVqv18wDXtrY25s2bx2tra4kX+n54s/M64N/gH5EHgP/7xGQSqe7u7lYhV3Z2Nua9vLzg6enpiF5fXxs/pW/gT+BvIF8A/gb+D3yKq4s/cIX2z/sT29vbH9s2fPLkSbS2trb68OHDH2uVSqXgVqv13wC/AwCgVCrl6unpATs7O9f5z3kK2d/fD6WlpQ9fXV3t5b3LsbGx/Nra2pIbnJ+f/w+Qy+W0W61Wqf56vR729/f/kYmRkZGMYwDwwv17eno251z5dCAQyC0Wi3k/Pz87f7+A0+m0f3Nzc3s4HF65yWZycnL24x+5XC4AIBqNQgUCAcDOzs7O1tZWvL+/P/F+f38/xGIxDAwM/JpZ1GAwSA+HQ6pQKMjJkycxsW6r1UoFAgEMDAwA1NbWwuLiYgwODsLl5eXoQSAQAAgEAhgYGPg1s6jBYJCeSqV0WCwWub+/H/f39+P8/HyPzwCgvb0dAICJiQmcTqflM2tO7+/vTxx+/vx5jMVi4OXl5X9+SAYGBgCcnZ2BIBAIkMvlYDAY/s1sKhgMkobD4Wr5fD6lVqs1Xl5exvX19b/X19e/19fX/4/5AOTz+QCA6urqIC4uDoFAIFqvzS0xMTHxh/sB+Xw+FkqlUqvVajWfz4eBgQF+s1+1Gg01GAxSTqcTYTabEY/HYWdnZ2fr6uoS4z0tPUfUajUrVqsVn88nAODs7AxxDeDk5IQpFAopFou1ZtfrNb7pSRQKEQ8fPhzL5/MBnJ2dgXg8/jX/Xzkcju/j8VguFotzTafTmUwmf3Z3d+f0ej0Wi8XpNEql0h+LRYIgCGf39/fLZ8kIBAKEgYGBFysUCgCAi4sLfL58eXl5GSA+Pj6W0+l0Xl5expw1qMVisVgs5tY8Gg22tbVlX1hY+EVFRUVnZ2fBbrd/+3a7/bN+s+v1erFcrvzr6+v/JpPJ4J35xIkTJ3p6eiKz2Xxar9e/+eXl5U8sFitfX1+PcXJyYtq2bQ+n0znnzMxMkMvlcnp6+o/v7+/r7e2t1Wr1u/b29n+1tbXlOI4vW1paHh8fD7lcrtfr9etLS0ufXlxc/PNf319fX//P/wKkUql0OByW0Wj8sFqtYLPZH38+n/+0XC6/n0wmP8lk8s/Z7HY7KBSK/1wul+8qlcq/Vqv1XygU/uX19fUvnU7n/Uaj8f9KpfI/oVDoX6PROBgM/m9sQ+w7g/8/l8sVsNls/qJSqb+lUumPFy9efF6r1T6bzeZ/stnsv6vV6h/X6/X/z6f3k0Ufgs2LwOLwCHgcrAaPw8Pgg/AhOM4X/n/D31/B/gU1Fh0wWlC6GgAAAABJRU5ErkJggg==' alt="Mirra Logo" style="height: 24px;">
                <h1>Claims Processing Dashboard</h1>
            </div>
            <a href="/admin.html" class="btn btn-outline-primary">Admin Console</a>
        </header>

        <!-- File Input & Options -->
        <div class="card p-3 mb-4 bg-light border-0">
            <h5>1. Upload Claims Data</h5>
            <input class="form-control" type="file" id="reportFile" accept=".xlsx, .csv">
        </div>
        <div class="card p-3 mb-4">
            <h5>2. Report Options</h5>
            <div class="row align-items-end">
                <div class="col-md-6 mb-3"><label for="configSelector" class="form-label small fw-bold">Select Report Configuration</label><select class="form-select" id="configSelector"><option>Loading...</option></select></div>
                <div class="col-md-6 mb-3"><label for="clientName" class="form-label small fw-bold">Client Name</label><input type="text" class="form-control" id="clientName" readonly></div>
            </div>
        </div>
        
        <div id="dashboardContent" style="display: none;">
            <!-- Download Buttons Section -->
            <div class="card p-3 mb-4">
                <h5 class="card-title fw-bold">3. Download Reports</h5>
                <div id="teamReportButtons" class="d-grid gap-2 d-md-flex">
                    <p class="text-muted">Process a file to generate download buttons.</p>
                </div>
                 <hr>
                 <button class="btn btn-dark w-100" id="generatePdfBtn">Download Detailed PDF Summary</button>
            </div>

            <!-- Tab Navigation -->
            <ul class="nav nav-tabs" id="mainTabs" role="tablist">
                <li class="nav-item" role="presentation"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#dashboard-pane" type="button">Analytics Dashboard</button></li>
                <li class="nav-item" role="presentation"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#work-queue-pane" type="button">Operational Work Queue</button></li>
            </ul>

            <!-- Tab Content -->
            <div class="tab-content border border-top-0 p-3 bg-white">
                <!-- Dashboard Pane -->
                <div class="tab-pane fade show active" id="dashboard-pane">
                    <!-- Dashboard charts and cards will be rendered here -->
                </div>
                <!-- Work Queue Pane -->
                <div class="tab-pane fade" id="work-queue-pane" role="tabpanel">
                    <div class="card p-3 mb-3 bg-light border-0">
                        <label for="categoryFilter" class="form-label fw-bold">Filter by Category</label>
                        <select id="categoryFilter" class="form-select"></select>
                    </div>
                    <div class="table-responsive">
                        <table class="table table-striped table-hover" id="work-queue-table">
                            <thead>
                                <tr>
                                    <th data-sort="priorityScore">Priority Score</th>
                                    <th data-sort="category">Category</th>
                                    <th data-sort="source">Source</th>
                                    <th data-sort="teamName">Assigned Team</th>
                                    <th data-sort="claimId">Claim ID</th>
                                    <th data-sort="age">Age</th>
                                    <th data-sort="netPayment">Amount at Risk</th>
                                    <th data-sort="providerName">Billing Provider</th>
                                </tr>
                            </thead>
                            <tbody id="work-queue-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
    // --- Global Variables ---
    let allClaimsData = [], aggregatedMetrics = {}, myCharts = {}, currentSort = { column: 'priorityScore', direction: 'desc' }, currentColumnMappings = {}, allConfigs = [];
    let categorizationConfig = { editRulesMap: new Map(), noteRulesMap: new Map() };

    // --- SMART getVal FUNCTION ---
    const getVal = (claim, standardKey) => {
        const mappedKey = currentColumnMappings[standardKey];
        return (mappedKey && claim[mappedKey] !== undefined) ? claim[mappedKey] : undefined;
    };

    // --- DYNAMIC CATEGORIZATION LOGIC ---
    async function loadCategorizationConfig() {
        try {
            const response = await fetch('/.netlify/functions/get-categorization-config');
            const config = await response.json();
            categorizationConfig.editRulesMap = new Map(config.editRules.map(r => [r.edit_text, { category: r.category_name, teamId: r.team_id, teamName: r.team_name }]));
            categorizationConfig.noteRulesMap = new Map(config.noteRules.map(r => [r.note_keyword, { category: r.category_name, teamId: r.team_id, teamName: r.team_name }]));
        } catch (error) { console.error("Could not load categorization rules:", error); }
    }

    // *** THIS FUNCTION IS MODIFIED FOR THE FIX ***
    function getClaimCategory(claim) {
        // Use .trim() to handle whitespace issues for exact matching
        const notes = (getVal(claim, 'notes') || '').toString().trim();
        const edit = (getVal(claim, 'edit') || '').toString().trim();

        // 1. Check for a DB rule match in Claim Edits
        if (edit && categorizationConfig.editRulesMap.has(edit)) {
            const rule = categorizationConfig.editRulesMap.get(edit);
            return { ...rule, source: 'Edit Rule' };
        }

        // 2. Check for an EXACT match in Claim Notes
        if (notes && categorizationConfig.noteRulesMap.has(notes)) {
            const rule = categorizationConfig.noteRulesMap.get(notes);
            return { ...rule, source: 'Note Rule' };
        }
        
        // 3. Fallback logic
        const totalCharges = parseFloat(getVal(claim, 'totalCharges') || 0);
        if (totalCharges > 50000) return { category: 'On Hold: High Dollar Review', source: 'Fallback', teamName: 'High Dollar Review Team' };
        // Use .includes() for fallback keywords
        if ((notes || '').toLowerCase().includes('duplicate') || (edit || '').toLowerCase().includes('duplicate')) return { category: 'On Hold: Duplicate', source: 'Fallback', teamName: 'Onshore' };
        
        // 4. Default
        return { category: 'Needs Triage', source: 'Default', teamName: 'Onshore' };
    }

    // --- CONFIGURATION & EVENT LISTENERS ---
    async function populateConfigSelector() {
        try {
            const response = await fetch('/.netlify/functions/configurations');
            const configs = await response.json();
            allConfigs = configs;
            const configSelector = document.getElementById('configSelector');
            configSelector.innerHTML = '<option value="">Load a saved configuration...</option>';
            configs.forEach(config => configSelector.add(new Option(config.config_name, config.id)));
        } catch (error) { console.error('Error populating configurations:', error); }
    }

    document.getElementById('configSelector').addEventListener('change', (e) => {
        const selectedId = parseInt(e.target.value, 10);
        const selectedConfig = allConfigs.find(c => c.id === selectedId);
        const clientNameInput = document.getElementById('clientName');
        if (selectedConfig?.config_data) {
            clientNameInput.value = selectedConfig.config_data.clientName || '';
            currentColumnMappings = selectedConfig.config_data.columnMappings || {};
            if (allClaimsData.length > 0) handleFile(null, true); 
        } else {
            clientNameInput.value = '';
            currentColumnMappings = {};
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('reportFile').addEventListener('change', (e) => handleFile(e, false));
        document.getElementById('generatePdfBtn').addEventListener('click', generateStructuredPDF);
        document.getElementById('work-queue-table').querySelector('thead').addEventListener('click', (e) => {
            const header = e.target.closest('th');
            if (header?.dataset.sort) {
                const sortKey = header.dataset.sort;
                currentSort.direction = (currentSort.column === sortKey && currentSort.direction === 'desc') ? 'asc' : 'desc';
                currentSort.column = sortKey;
                renderWorkQueue(allClaimsData);
            }
        });
        document.getElementById('categoryFilter').addEventListener('change', () => renderWorkQueue(allClaimsData));
        populateConfigSelector();
        loadCategorizationConfig();
    });

    // --- MAIN FILE HANDLING AND PROCESSING LOGIC ---
    function handleFile(event, isReprocessing = false) {
        if (!isReprocessing && !event.target.files[0]) return;
        if (Object.keys(currentColumnMappings).length === 0) {
            alert("Please select a report configuration first.");
            if (event) event.target.value = "";
            return;
        }
        const processAndRender = (data) => {
            try {
                const processedData = analyzeAndProcessClaims(data);
                allClaimsData = processedData.claims;
                aggregatedMetrics = processedData.metrics;
                renderDashboard(allClaimsData, aggregatedMetrics);
                populateCategoryFilter(allClaimsData);
                renderWorkQueue(allClaimsData);
                document.getElementById('dashboardContent').style.display = 'block';
            } catch (error) {
                console.error("An error during file processing:", error);
                alert("Failed to process the file. Check console for details.");
            }
        };
        if (isReprocessing) {
            processAndRender(allClaimsData.map(c => c.original));
            return;
        }
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = (e) => {
            if (file.name.endsWith('.csv')) {
                Papa.parse(e.target.result, { header: true, skipEmptyLines: true, complete: (res) => processAndRender(res.data) });
            } else {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                processAndRender(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]));
            }
        };
        file.name.endsWith('.csv') ? reader.readAsText(file) : reader.readAsArrayBuffer(file);
    }

    function analyzeAndProcessClaims(data) {
        const metrics = { totalClaims: 0, totalNetPayment: 0, claimsPend: 0, claimsDenied: 0, claimsByStatus: {}, claimsByState: {}, claimsByNetwork: {}, claimsByEdit: {}, providerCounts: { overall: {}, onhold: {}, mgmtreview: {} }};
        const claims = data.map(rawClaim => {
            const processedClaim = {
                state: (getVal(rawClaim, 'state') || 'UNKNOWN').toString().toUpperCase().trim(),
                status: (getVal(rawClaim, 'status') || 'UNKNOWN').toString().toUpperCase().trim(),
                age: parseInt(getVal(rawClaim, 'age') || 0),
                netPayment: parseFloat(getVal(rawClaim, 'netPayment') || 0),
                networkStatus: getVal(rawClaim, 'networkStatus') || 'Unknown',
                edit: getVal(rawClaim, 'edit') || 'No Edits',
                providerName: getVal(rawClaim, 'providerName') || 'Unknown',
                claimId: getVal(rawClaim, 'claimId') || 'N/A',
                original: rawClaim
            };
            metrics.totalClaims++;
            if (!isNaN(processedClaim.netPayment)) metrics.totalNetPayment += processedClaim.netPayment;
            if (processedClaim.state === 'PEND') metrics.claimsPend++;
            if (processedClaim.status === 'DENY') metrics.claimsDenied++;
            metrics.claimsByStatus[processedClaim.status] = (metrics.claimsByStatus[processedClaim.status] || 0) + 1;
            metrics.claimsByState[processedClaim.state] = (metrics.claimsByState[processedClaim.state] || 0) + 1;
            metrics.claimsByNetwork[processedClaim.networkStatus] = (metrics.claimsByNetwork[processedClaim.networkStatus] || 0) + 1;
            metrics.claimsByEdit[processedClaim.edit] = (metrics.claimsByEdit[processedClaim.edit] || 0) + 1;
            metrics.providerCounts.overall[processedClaim.providerName] = (metrics.providerCounts.overall[processedClaim.providerName] || 0) + 1;
            if (processedClaim.state === 'ONHOLD') metrics.providerCounts.onhold[processedClaim.providerName] = (metrics.providerCounts.onhold[processedClaim.providerName] || 0) + 1;
            if (processedClaim.state === 'MANAGEMENTREVIEW') metrics.providerCounts.mgmtreview[processedClaim.providerName] = (metrics.providerCounts.mgmtreview[processedClaim.providerName] || 0) + 1;

            processedClaim.isActionable = ['PEND', 'ONHOLD', 'MANAGEMENTREVIEW'].includes(processedClaim.state) || processedClaim.status === 'DENY';
            if (processedClaim.isActionable) {
                const categoryInfo = getClaimCategory(rawClaim);
                processedClaim.category = categoryInfo.category;
                processedClaim.source = categoryInfo.source;
                processedClaim.teamId = categoryInfo.teamId;
                processedClaim.teamName = categoryInfo.teamName;
                processedClaim.priorityScore = getPriorityScore(processedClaim);
            } else {
                processedClaim.category = 'N/A';
                processedClaim.source = 'N/A';
                processedClaim.teamName = 'N/A';
                processedClaim.priorityScore = -1;
            }
            return processedClaim;
        });
        const getTop10 = (counts, filterKey = null) => Object.entries(counts).filter(([k]) => k !== filterKey).sort(([, a], [, b]) => b - a).slice(0, 10).reduce((acc, [l, d]) => (acc.labels.push(l), acc.data.push(d), acc), { labels: [], data: [] });
        metrics.topEdits = getTop10(metrics.claimsByEdit, 'No Edits');
        metrics.topProvidersOverall = getTop10(metrics.providerCounts.overall);
        metrics.topProvidersOnHold = getTop10(metrics.providerCounts.onhold);
        metrics.topProvidersMgmtReview = getTop10(metrics.providerCounts.mgmtreview);
        return { claims, metrics };
    }
    
    function getPriorityScore(claim) {
        const totalCharges = parseFloat(getVal(claim.original, 'totalCharges') || 0);
        const age = parseInt(claim.age || 0);
        const status = (claim.status || '').toUpperCase();
        let score = 0;
        score += (totalCharges / 500);
        score += (age * 1.5);
        if (status === 'DENY') score += 100;
        return Math.round(score);
    }

    function renderDashboard(claims, metrics) {
        populateTeamDownloadButtons(claims);
        const dashboardPane = document.getElementById('dashboard-pane');
        dashboardPane.innerHTML = `
            <div id="executive-summary-section" class="dashboard-section">
                <h2 class="h4 text-muted mb-4" style="font-weight: 300;">Executive Summary</h2>
                <div class="row g-4 mb-5" id="executive-summary-cards"></div>
            </div>
            <div id="workflow-network-section" class="dashboard-section">
                <div class="section-header"><h2 class="h5">Workflow & Network Analysis</h2></div>
                <div class="row g-4 mb-5">
                    <div class="col-lg-4 col-md-6"><div class="chart-container"><h6 class="text-center text-dark">Claims Volume by Final Status</h6><canvas id="statusChart"></canvas></div></div>
                    <div class="col-lg-4 col-md-6"><div class="chart-container"><h6 class="text-center text-dark">Claims Volume by Workflow State</h6><canvas id="stateChart"></canvas></div></div>
                    <div class="col-lg-4 col-md-6"><div class="chart-container"><h6 class="text-center text-dark">In-Network vs. Out-of-Network</h6><canvas id="networkChart"></canvas></div></div>
                </div>
            </div>
            <div id="root-cause-section" class="dashboard-section">
                 <div class="section-header"><h2 class="h5">Root Cause Analysis</h2></div>
                 <div class="row g-4 mb-5">
                    <div class="col-lg-3 col-md-6"><div class="chart-container"><h6 class="text-center text-dark">Top 10 Claim Edits</h6><canvas id="editsChart"></canvas></div></div>
                    <div class="col-lg-3 col-md-6"><div class="chart-container"><h6 class="text-center text-dark">Top 10 Billing Providers (Overall)</h6><canvas id="providerOverallChart"></canvas></div></div>
                    <div class="col-lg-3 col-md-6"><div class="chart-container"><h6 class="text-center text-dark">Top 10 Billing Providers (On Hold)</h6><canvas id="providerOnHoldChart"></canvas></div></div>
                    <div class="col-lg-3 col-md-6"><div class="chart-container"><h6 class="text-center text-dark">Top 10 Billing Providers (Mgmt Review)</h6><canvas id="providerMgmtReviewChart"></canvas></div></div>
                </div>
            </div>`;

        const fNum = (num) => num.toLocaleString('en-US');
        const fCur = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        document.getElementById('executive-summary-cards').innerHTML = `<div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #0d6efd;"><div class="metric-label">TOTAL CLAIMS</div><div class="metric-value">${fNum(metrics.totalClaims)}</div></div></div><div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #198754;"><div class="metric-label">TOTAL NET PAYMENT (PENDING)</div><div class="metric-value">${fCur(metrics.totalNetPayment)}</div></div></div><div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #ffc107;"><div class="metric-label">CLAIMS PEND STATUS</div><div class="metric-value">${fNum(metrics.claimsPend)}</div></div></div><div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #dc3545;"><div class="metric-label">CLAIMS DENIED</div><div class="metric-value">${fNum(metrics.claimsDenied)}</div></div></div>`;
        
        Object.values(myCharts).forEach(chart => chart.destroy());
        const doughnutOpts = { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom' } } };
        const barOpts = { responsive: true, maintainAspectRatio: false, indexAxis: 'y', plugins: { legend: { display: false } } };
        const createChart = (id, type, data, options) => new Chart(document.getElementById(id), { type, data, options });
        myCharts.statusChart = createChart('statusChart', 'doughnut', { labels: Object.keys(metrics.claimsByStatus), datasets: [{ data: Object.values(metrics.claimsByStatus) }] }, doughnutOpts);
        myCharts.stateChart = createChart('stateChart', 'doughnut', { labels: Object.keys(metrics.claimsByState), datasets: [{ data: Object.values(metrics.claimsByState) }] }, doughnutOpts);
        myCharts.networkChart = createChart('networkChart', 'doughnut', { labels: Object.keys(metrics.claimsByNetwork), datasets: [{ data: Object.values(metrics.claimsByNetwork) }] }, doughnutOpts);
        myCharts.editsChart = createChart('editsChart', 'bar', { labels: metrics.topEdits.labels, datasets: [{ data: metrics.topEdits.data, backgroundColor: '#465a6c' }] }, barOpts);
        myCharts.providerOverallChart = createChart('providerOverallChart', 'bar', { labels: metrics.topProvidersOverall.labels, datasets: [{ data: metrics.topProvidersOverall.data, backgroundColor: '#007bff' }] }, barOpts);
        myCharts.providerOnHoldChart = createChart('providerOnHoldChart', 'bar', { labels: metrics.topProvidersOnHold.labels, datasets: [{ data: metrics.topProvidersOnHold.data, backgroundColor: '#ffc107' }] }, barOpts);
        myCharts.providerMgmtReviewChart = createChart('providerMgmtReviewChart', 'bar', { labels: metrics.topProvidersMgmtReview.labels, datasets: [{ data: metrics.topProvidersMgmtReview.data, backgroundColor: '#dc3545' }] }, barOpts);
    }

    function populateCategoryFilter(claims) {
        const filter = document.getElementById('categoryFilter');
        const categories = [...new Set(claims.filter(c => c.isActionable).map(c => c.category))];
        filter.innerHTML = '<option value="all" selected>All Actionable Categories</option>';
        categories.sort().forEach(cat => {
            filter.add(new Option(cat, cat));
        });
    }

    function renderWorkQueue(claims) {
        const selectedCategory = document.getElementById('categoryFilter').value;
        let actionable = claims.filter(c => c.isActionable);
        if (selectedCategory !== 'all') {
            actionable = actionable.filter(c => c.category === selectedCategory);
        }
        actionable.sort((a, b) => {
            const valA = a[currentSort.column], valB = b[currentSort.column];
            let comp = 0;
            if(typeof valA === 'number' && typeof valB === 'number') comp = valA - valB;
            else comp = (valA || '').toString().localeCompare((valB || '').toString());
            return currentSort.direction === 'asc' ? comp : -comp;
        });
        document.getElementById('work-queue-body').innerHTML = actionable.map(claim =>
            `<tr>
                <td>${claim.priorityScore}</td>
                <td>${claim.category || 'N/A'}</td>
                <td>${claim.source || 'N/A'}</td>
                <td>${claim.teamName || 'N/A'}</td>
                <td>${claim.claimId || 'N/A'}</td>
                <td>${claim.age || 0}</td>
                <td>$${(claim.netPayment || 0).toFixed(2)}</td>
                <td>${claim.providerName || 'N/A'}</td>
            </tr>`
        ).join('');
    }

    function populateTeamDownloadButtons(claims) {
        const container = document.getElementById('teamReportButtons');
        const actionableClaims = claims.filter(c => c.isActionable && c.teamName);
        const teams = [...new Set(actionableClaims.map(c => c.teamName))];
        container.innerHTML = '';
        if (teams.length === 0) {
            container.innerHTML = '<p class="text-muted">No actionable claims found for any team.</p>';
            return;
        }
        teams.sort().forEach(teamName => {
            const btn = document.createElement('button');
            btn.className = 'btn btn-success';
            btn.innerHTML = `<i class="bi bi-download"></i> Download ${teamName} Report`;
            btn.onclick = () => downloadTeamReport(teamName, actionableClaims);
            container.appendChild(btn);
        });
    }

    function downloadTeamReport(teamName, allActionableClaims) {
        const teamClaims = allActionableClaims.filter(c => c.teamName === teamName);
        if (teamClaims.length === 0) return alert(`No claims found for team: ${teamName}`);
        
        const claimsByCategory = teamClaims.reduce((acc, claim) => {
            const category = claim.category;
            if (!acc[category]) acc[category] = [];
            acc[category].push({
                ...claim.original,
                'Priority Score': claim.priorityScore, 'Assigned Team': claim.teamName,
                'Category': claim.category, 'Categorization Source': claim.source
            });
            return acc;
        }, {});

        const wb = XLSX.utils.book_new();
        const today = new Date().toISOString().slice(0, 10);
        Object.keys(claimsByCategory).sort().forEach(categoryName => {
            const ws = XLSX.utils.json_to_sheet(claimsByCategory[categoryName]);
            const safeSheetName = categoryName.replace(/[\/\\?*\[\]]/g, '').substring(0, 31);
            XLSX.utils.book_append_sheet(wb, ws, safeSheetName);
        });

        const clientName = document.getElementById('clientName').value.trim().replace(/ /g, '_') || 'Client';
        const safeTeamName = teamName.replace(/ /g, '_');
        const fileName = `${clientName}_${safeTeamName}_Report_${today}.xlsx`;
        XLSX.writeFile(wb, fileName);
    }
    
    async function generateStructuredPDF() {
        if (!aggregatedMetrics.totalClaims) { alert("Please load data first."); return; }
        const clientName = document.getElementById('clientName').value.trim();
        if (!clientName) { alert("Please select a report configuration to set a client name."); return; }
        const today = new Date(), formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        const pdfTitle = `${clientName} Daily Summary Report ${formattedDate}`;
        const fileName = `${clientName.replace(/ /g, '_')}_Daily_Summary_Report_${formattedDate}.pdf`;
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'pt', 'a4');
        const margin = 40, pageHeight = pdf.internal.pageSize.getHeight();
        let currentHeight = margin;
        
        try { const logoCanvas = await html2canvas(document.getElementById('logoImage'), { backgroundColor: null }); pdf.addImage(logoCanvas.toDataURL('image/png'), 'PNG', margin, currentHeight, 84, 24); } catch (e) { console.error("Error rendering logo for PDF:", e); }
        currentHeight += 40;

        const addMainTitle = (title) => { pdf.setFont('helvetica', 'bold'); pdf.setFontSize(22); pdf.text(title, pdf.internal.pageSize.getWidth() / 2, currentHeight, { align: 'center' }); currentHeight += 40; };
        const addSectionHeader = (title) => { if (currentHeight + 40 > pageHeight - margin) { pdf.addPage(); currentHeight = margin; } pdf.setFont('helvetica', 'bold'); pdf.setFontSize(16); pdf.text(title, margin, currentHeight); currentHeight += 25; };
        const addTableToPdf = (title, tableConfig) => {
            let rowCount = tableConfig.body ? tableConfig.body.length : 0;
            if (currentHeight + 45 + (rowCount * 15) > pageHeight - margin) { pdf.addPage(); currentHeight = margin; }
            pdf.setFont('helvetica', 'bold'); pdf.setFontSize(14);
            pdf.text(title, margin, currentHeight);
            pdf.autoTable({ ...tableConfig, startY: currentHeight + 15, theme: 'grid', headStyles: { fillColor: [70, 90, 108] } });
            currentHeight = pdf.autoTable.previous.finalY + 25;
        };

        addMainTitle(pdfTitle);
        addSectionHeader('Executive Summary');
        const canvas = await html2canvas(document.getElementById('executive-summary-cards'));
        const imgWidth = pdf.internal.pageSize.getWidth() - margin * 2;
        const imgHeight = canvas.height * imgWidth / canvas.width;
        if (currentHeight + imgHeight > pageHeight - margin) { pdf.addPage(); currentHeight = margin; }
        pdf.addImage(canvas.toDataURL('image/png'), 'PNG', margin, currentHeight, imgWidth, imgHeight);
        currentHeight += imgHeight + 20;

        pdf.addPage(); currentHeight = margin;
        addSectionHeader('Workflow & Root Cause Analysis');
        const toTableData = (obj) => Object.entries(obj).map(([k,v]) => [k,v]);
        const toTop10Data = (top10) => top10.labels.map((l, i) => [l, top10.data[i]]);
        addTableToPdf('Claims by Final Status', { head: [['Status', 'Count']], body: toTableData(aggregatedMetrics.claimsByStatus) });
        addTableToPdf('Claims by Workflow State', { head: [['State', 'Count']], body: toTableData(aggregatedMetrics.claimsByState) });
        addTableToPdf('Top 10 Claim Edits', { head: [['Edit', 'Count']], body: toTop10Data(aggregatedMetrics.topEdits) });
        addTableToPdf('Top 10 Providers (Overall)', { head: [['Provider', 'Count']], body: toTop10Data(aggregatedMetrics.topProvidersOverall) });
        
        pdf.save(fileName);
    }
    </script>
</body>
</html>
