<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Claims Dashboard & Analytics Engine</title>
    <!-- Stylesheets and Libraries (no changes here) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* CSS Styles (no changes here) */
        :root { --primary-color: #0d6efd; --secondary-color: #f8f9fa; }
        body { background-color: white; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
        .dashboard-card { border-radius: 0.375rem; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); border: 1px solid #dee2e6; border-left-width: 4px; padding: 1.25rem; }
        .metric-value { font-size: 2.25rem; font-weight: 700; color: #212529; }
        .metric-label { font-size: 0.8rem; font-weight: 600; text-transform: uppercase; }
        .chart-container { min-height: 380px; background-color: white; padding: 20px; border-radius: 0.5rem; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); }
        .section-header { background-color: #465a6c; color: white; padding: 8px 15px; border-radius: 0.25rem; margin-bottom: 1rem; }
        .aging-table-header { background-color: #465a6c; color: white; padding: 8px 15px; border-radius: 0.25rem; font-size: 1.1rem; margin-top: 1rem; }
        #work-queue-table th { background-color: #005A9C; color: white; cursor: pointer; }
        #dashboardContent { display: none; }
    </style>
</head>
<body>
    <div class="container-fluid p-4">
        <!-- Header Section (no changes) -->
        <header class="mb-4 d-flex justify-content-between align-items-center">
            <div>
                <img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAZCAYAAAC115MjAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARRSURBVChTPZf/a9NXHMc/520kLg3L+m2DIsO2pKGv+i8u/AN2d9FNHHRwdr3sDqYru93VzU5XV7c3o05FmJ2YqW432B/A68qKVgN6KVoLqS11475c7nN/eR5+25f6eRy9Dw79dE/u+RzP53O+z+f+uD/wPz3uA1fC42BxeBQ8DheDh8HDZfD4WIKzVqv18wDXtrY25s2bx2tra4kX+n54s/M64N/gH5EHgP/7xGQSqe7u7lYhV3Z2Nua9vLzg6enpiF5fXxs/pW/gT+BvIF8A/gb+D3yKq4s/cIX2z/sT29vbH9s2fPLkSbS2trb68OHDH2uVSqXgVqv13wC/AwCgVCrl6unpATs7O9f5z3kK2d/fD6WlpQ9fXV3t5b3LsbGx/Nra2pIbnJ+f/w+Qy+W0W61Wqf56vR729/f/kYmRkZGMYwDwwv17eno251z5dCAQyC0Wi3k/Pz87f7+A0+m0f3Nzc3s4HF65yWZycnL24x+5XC4AIBqNQgUCAcDOzs7O1tZWvL+/P/F+f38/xGIxDAwM/JpZ1GAwSA+HQ6pQKMjJkycxsW6r1UoFAgEMDAwA1NbWwuLiYgwODsLl5eXoQSAQAAgEAhgYGPg1s6jBYJCeSqV0WCwWub+/H/f39+P8/HyPzwCgvb0dAICJiQmcTqflM2tO7+/vTxx+/vx5jMVi4OXl5X9+SAYGBgCcnZ2BIBAIkMvlYDAY/s1sKhgMkobD4Wr5fD6lVqs1Xl5exvX19b/X19e/19fX/4/5AOTz+QCA6urqIC4uDoFAIFqvzS0xMTHxh/sB+Xw+FkqlUqvVajWfz4eBgQF+s1+1Gg01GAxSTqcTYTabEY/HYWdnZ2fr6uoS4z09PUfUajUrVqsVn88nAODs7AxxDeDk5IQpFAopFou1ZtfrNb7pSRQKEQ8fPhzL5/MBnJ2dgXg8/jX/Xzkcju/j8VguFotzTafTmUwmf3Z3d+f0ej0Wi8XpNEql0h+LRYIgCGf39/fLZ8kIBAKEgYGBFysUCgCAi4sLfL58eXl5GSA+Pj6W0+l0Xl5expw1qMVisVgs5tY8Gg22tbVlX1hY+EVFRUVnZ2fBbrd/+3a7/bN+s+v1erFcrvzr6+v/JpPJ4J35xIkTJ3p6eiKz2Xxar9e/+eXl5U8sFitfX1+PcXJyYtq2bQ+n0znnzMxMkMvlcnp6+o/v7+/r7e2t1Wr1u/b29n+1tbXlOI4vW1paHh8fD7lcrtfr9etLS0ufXlxc/PNf319fX//P/wKkUql0OByW0Wj8sFqtYLPZH38+n/+0XC6/n0wmP8lk8s/Z7HY7KBSK/1wul+8qlcq/Vqv1XygU/uX19fUvnU7n/Uaj8f9KpfI/oVDoX6PROBgM/m9sQ+w7g/8/l8sVsNls/qJSqb+lUumPFy9efF6r1T6bzeZ/stnsv6vV6h/X6/X/z6f3k0Ufgs2LwOLwCHgcrAaPw8Pgg/AhOM4X/n/D31/B/gU1Fh0wWlC6GgAAAABJRU5ErkJggg==' alt="Mirra Logo" style="height: 24px;">
                <h1 class="display-6" style="color: #0d6efd;">Claims Processing Dashboard</h1>
            </div>
            <a href="/admin.html" class="btn btn-outline-primary">Admin Page</a>
        </header>

        <!-- File Input & Options (no changes) -->
        <div class="card p-3 mb-4 bg-light border-0">
            <h5 class="card-title fw-bold">1. Upload Claims Data</h5>
            <input class="form-control" type="file" id="reportFile" accept=".xlsx, .csv">
        </div>
        <div id="dashboardOptions">
            <div class="pdf-options card p-3 mb-4">
                <h5 class="card-title fw-bold">2. Report Options</h5>
                <div class="row align-items-end">
                    <div class="col-md-6 mb-3">
                        <label for="configSelector" class="form-label small fw-bold">Select Report Configuration</label>
                        <select class="form-select" id="configSelector">
                            <option value="">Loading configurations...</option>
                        </select>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="clientName" class="form-label small fw-bold">Client Name</label>
                        <input type="text" class="form-control" id="clientName" readonly>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Dashboard Content (no changes to HTML structure) -->
        <div id="dashboardContent">
            <!-- Download Button, Tabs, etc. -->
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- Global Variables ---
        let allClaimsData = [];
        let aggregatedMetrics = {};
        let myCharts = {};
        let currentSort = { column: 'priorityScore', direction: 'desc' };
        let currentColumnMappings = {}; 
        let allConfigs = [];
        // NEW: Global variable for the categorization rules
        let categorizationConfig = { editRulesMap: new Map(), noteRulesMap: new Map() };

        // --- SMART getVal FUNCTION (Unchanged) ---
        const getVal = (claim, standardKey) => {
            const mappedKey = currentColumnMappings[standardKey];
            return (mappedKey && claim[mappedKey] !== undefined) ? claim[mappedKey] : undefined;
        };

        // --- NEW/UPDATED FUNCTIONS ---

        // NEW: Fetches categorization rules from the new endpoint
        async function loadCategorizationConfig() {
            try {
                const response = await fetch('/.netlify/functions/get-categorization-config');
                if (!response.ok) throw new Error('Failed to fetch categorization config');
                const config = await response.json();
                
                // Convert arrays to Maps for efficient lookups
                categorizationConfig.editRulesMap = new Map(config.editRules.map(r => [r.edit_text, r.category_name]));
                categorizationConfig.noteRulesMap = new Map(config.noteRules.map(r => [r.note_keyword, r.category_name]));

            } catch (error) {
                console.error("Could not load categorization rules:", error);
                // App can still function with the fallback logic, so no alert.
            }
        }

        // UPDATED: Replaced the old hardcoded function with the new dynamic one
        function getClaimCategory(claim) {
            const notes = (getVal(claim, 'notes') || '').toLowerCase();
            const edit = getVal(claim, 'edit'); // Use original case for exact matching

            // 1. Check for an exact match in Claim Edits using the new rules map
            if (edit && categorizationConfig.editRulesMap.has(edit)) {
                return categorizationConfig.editRulesMap.get(edit);
            }

            // 2. Search for keywords in Claim Notes using the new rules map
            if (notes) {
                for (const [keyword, category] of categorizationConfig.noteRulesMap.entries()) {
                    if (notes.includes(keyword)) {
                        return category;
                    }
                }
            }
            
            // 3. Fallback to original logic if no database rule matches, ensuring backwards compatibility
            if (notes.includes('w9')) return 'Action Required: Missing W9';
            if (notes.includes('duplicate') || (edit || '').toLowerCase().includes('duplicate')) return 'On Hold: Duplicate';

            // 4. Default category if no other rule applies
            return 'Needs Triage';
        }

        // --- CONFIGURATION & EVENT LISTENERS ---
        async function populateConfigSelector() {
            try {
                const response = await fetch('/.netlify/functions/configurations');
                const configs = await response.json();
                allConfigs = configs;
                const configSelector = document.getElementById('configSelector');
                configSelector.innerHTML = '<option value="">Load a saved configuration...</option>';
                configs.forEach(config => {
                    configSelector.add(new Option(config.config_name, config.id));
                });
            } catch (error) {
                console.error('Error populating configurations:', error);
            }
        }

        document.getElementById('configSelector').addEventListener('change', (e) => {
            const selectedId = parseInt(e.target.value, 10);
            const selectedConfig = allConfigs.find(c => c.id === selectedId);
            const clientNameInput = document.getElementById('clientName');
            
            if (selectedConfig?.config_data) {
                clientNameInput.value = selectedConfig.config_data.clientName || '';
                currentColumnMappings = selectedConfig.config_data.columnMappings || {};
                // If data is already loaded, re-process it with the new mappings
                if (allClaimsData.length > 0) handleFile(null, true); 
            } else {
                clientNameInput.value = '';
                currentColumnMappings = {};
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('reportFile').addEventListener('change', (e) => handleFile(e, false));
            // All other event listeners for PDF generation, sorting, etc. remain here...

            // Fetch both client configs and categorization rules on page load
            populateConfigSelector();
            loadCategorizationConfig();
        });

        // --- Main file handling and processing logic (Unchanged) ---
        function handleFile(event, isReprocessing = false) {
            if (!isReprocessing && !event.target.files[0]) return;
            if (Object.keys(currentColumnMappings).length === 0) {
                alert("Please select a report configuration first.");
                if(event) event.target.value = "";
                return;
            }
            const processAndRender = (data) => {
                try {
                    const processedData = analyzeAndProcessClaims(data);
                    allClaimsData = processedData.claims;
                    aggregatedMetrics = processedData.metrics;
                    renderDashboard(allClaimsData, aggregatedMetrics);
                    // Other rendering functions...
                    document.getElementById('dashboardContent').style.display = 'block';
                } catch (error) {
                    console.error("File processing error:", error);
                    alert("Failed to process file. Check console for details.");
                }
            };
            if (isReprocessing) {
                processAndRender(allClaimsData.map(c => c.original));
                return;
            }
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = file.name.endsWith('.csv') ? Papa.parse(e.target.result, { header: true, skipEmptyLines: true }).data 
                                                       : XLSX.utils.sheet_to_json(XLSX.read(new Uint8Array(e.target.result), { type: 'array' }).Sheets[workbook.SheetNames[0]]);
                processAndRender(data);
            };
            file.name.endsWith('.csv') ? reader.readAsText(file) : reader.readAsArrayBuffer(file);
        }

        // The analyzeAndProcessClaims function and all other rendering functions
        // (renderDashboard, renderAgingTables, etc.) remain exactly the same.
        // The only change needed was updating getClaimCategory.
        function analyzeAndProcessClaims(data) {
            // This entire function remains the same as your previous version.
            // It calls the NEW getClaimCategory function, so its behavior is automatically updated.
            const metrics = { totalClaims: 0, /* ... other metrics */ };
            const claims = data.map(rawClaim => {
                const processedClaim = { /* ... processing logic */ };
                
                // This is the key part: it now uses the dynamic function
                processedClaim.category = getClaimCategory(rawClaim); 

                // ... rest of the analysis
                return processedClaim;
            });
            // ... calculate top 10s, averages, etc.
            return { claims, metrics };
        }
        
        // All other functions like getPriorityScore, renderDashboard, renderAgingTables,
        // createAgingTableHTML, generateStructuredPDF, etc., remain unchanged.

    </script>
</body>
</html>
