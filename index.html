<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Claims Dashboard & Analytics Engine</title>
    <!-- Bootstrap 5 for Layout and Styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons for Buttons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <!-- Chart.js for Graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- SheetJS (XLSX) & PapaParse (CSV) Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <!-- Libraries for Advanced PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <style>
        :root { --primary-color: #0d6efd; --secondary-color: #f8f9fa; }
        body { background-color: white; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
        .dashboard-card { border-radius: 0.375rem; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); border: 1px solid #dee2e6; border-left-width: 4px; padding: 1.25rem; }
        .metric-value { font-size: 2.25rem; font-weight: 700; color: #212529; }
        .metric-label { font-size: 0.8rem; font-weight: 600; text-transform: uppercase; }
        .chart-container { min-height: 380px; background-color: white; padding: 20px; border-radius: 0.5rem; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); }
        .section-header { background-color: #465a6c; color: white; padding: 8px 15px; border-radius: 0.25rem; margin-bottom: 1rem; }
        .aging-table-header { background-color: #465a6c; color: white; padding: 8px 15px; border-radius: 0.25rem; font-size: 1.1rem; margin-top: 1rem; }
        .aging-table thead { background-color: #f1f4f6; }
        #dashboardContent { display: none; }
        #work-queue-table th { background-color: #005A9C; color: white; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container-fluid p-4">
        <!-- Header Section -->
        <header class="mb-4 d-flex justify-content-between align-items-center">
            <div>
                <img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAZCAYAAAC115MjAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARRSURBVChTPZf/a9NXHMc/520kLg3L+m2DIsO2pKGv+i8u/AN2d9FNHHRwdr3sDqYru93VzU5XV7c3o05FmJ2YqW432B/A68qKVgN6KVoLqS11475c7nN/eR5+25f6eRy9Dw79dE/u+RzP53O+z+f+uD/wPz3uA1fC42BxeBQ8DheDh8HDZfD4WIKzVqv18wDXtrY25s2bx2tra4kX+n54s/M64N/gH5EHgP/7xGQSqe7u7lYhV3Z2Nua9vLzg6enpiF5fXxs/pW/gT+BvIF8A/gb+D3yKq4s/cIX2z/sT29vbH9s2fPLkSbS2trb68OHDH2uVSqXgVqv13wC/AwCgVCrl6unpATs7O9f5z3kK2d/fD6WlpQ9fXV3t5b3LsbGx/Nra2pIbnJ+f/w+Qy+W0W61Wqf56vR729/f/kYmRkZGMYwDwwv17eno251z5dCAQyC0Wi3k/Pz87f7+A0+m0f3Nzc3s4HF65yWZycnL24x+5XC4AIBqNQgUCAcDOzs7O1tZWvL+/P/F+f38/xGIxDAwM/JpZ1GAwSA+HQ6pQKMjJkycxsW6r1UoFAgEMDAwA1NbWwuLiYgwODsLl5eXoQSAQAAgEAhgYGPg1s6jBYJCeSqV0WCwWub+/H/f39+P8/HyPzwCgvb0dAICJiQmcTqflM2tO7+/vTxx+/vx5jMVi4OXl5X9+SAYGBgCcnZ2BIBAIkMvlYDAY/s1sKhgMkobD4Wr5fD6lVqs1Xl5exvX19b/X19e/19fX/4/5AOTz+QCA6urqIC4uDoFAIFqvzS0xMTHxh/sB+Xw+FkqlUqvVajWfz4eBgQF+s1+1Gg01GAxSTqcTYTabEY/HYWdnZ2fr6uoS4z09PUfUajUrVqsVn88nAODs7AxxDeDk5IQpFAopFou1ZtfrNb7pSRQKEQ8fPhzL5/MBnJ2dgXg8/jX/Xzkcju/j8VguFotzTafTmUwmf3Z3d+f0ej0Wi8XpNEql0h+LRYIgCGf39/fLZ8kIBAKEgYGBFysUCgCAi4sLfL58eXl5GSA+Pj6W0+l0Xl5expw1qMVisVgs5tY8Gg22tbVlX1hY+EVFRUVnZ2fBbrd/+3a7/bN+s+v1erFcrvzr6+v/JpPJ4J35xIkTJ3p6eiKz2Xxar9e/+eXl5U8sFitfX1+PcXJyYtq2bQ+n0znnzMxMkMvlcnp6+o/v7+/r7e2t1Wr1u/b29n+1tbXlOI4vW1paHh8fD7lcrtfr9etLS0ufXlxc/PNf319fX//P/wKkUql0OByW0Wj8sFqtYLPZH38+n/+0XC6/n0wmP8lk8s/Z7HY7KBSK/1wul+8qlcq/Vqv1XygU/uX19fUvnU7n/Uaj8f9KpfI/oVDoX6PROBgM/m9sQ+w7g/8/l8sVsNls/qJSqb+lUumPFy9efF6r1T6bzeZ/stnsv6vV6h/X6/X/z6f3k0Ufgs2LwOLwCHgcrAaPw8Pgg/AhOM4X/n/D31/B/gU1Fh0wWlC6GgAAAABJRU5kJggg==' alt="Mirra Logo" style="height: 24px; margin-bottom: 10px;" id="logoImage">
                <h1 class="display-6" style="color: #0d6efd;" id="mainTitle">Claims Processing Daily Dashboard</h1>
            </div>
            <a href="/admin.html" class="btn btn-outline-primary">Go to Admin Console</a>
        </header>

        <div id="dashboardOptions">
            <div class="pdf-options card p-3 mb-4">
                <h5 class="card-title fw-bold">1. Report Options</h5>
                <div class="row align-items-end">
                    <div class="col-md-6 mb-3">
                        <label for="configSelector" class="form-label small fw-bold">Select Report Configuration</label>
                        <select class="form-select form-select-sm" id="configSelector">
                            <option value="">Loading configurations...</option>
                        </select>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="clientName" class="form-label small fw-bold">Client Name</label>
                        <input type="text" class="form-control form-select-sm" id="clientName" placeholder="Select a configuration" readonly>
                    </div>
                </div>
            </div>
        </div>

        <!-- File Input Section -->
        <div class="card p-3 mb-4 bg-light border-0">
            <h5 class="card-title fw-bold">2. Upload Claims Data</h5>
            <label for="reportFile" class="form-label">Select an XLSX or CSV file to begin analysis.</label>
            <input class="form-control" type="file" id="reportFile" accept=".xlsx, .csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
        </div>

        <!-- Optional Provider Verification Report Upload -->
        <div class="card p-3 mb-4">
            <h5 class="card-title fw-bold">3. Optional: Upload Provider Verification Data</h5>
            <label for="providerReportFile" class="form-label">Select the corresponding provider verification report. This will enrich the work queue with W9 and approval statuses.</label>
            <input class="form-control" type="file" id="providerReportFile" accept=".xlsx, .csv" disabled>
        </div>
        
        <div id="dashboardContent" style="display: none;">
            <!-- Download Buttons Section -->
            <div class="card p-3 mb-4">
                <h5 class="card-title fw-bold">4. Download Reports</h5>
                <div id="teamReportButtons" class="d-grid gap-2 d-md-flex mb-3">
                    <p class="text-muted">Process a file to generate download buttons for each team.</p>
                </div>
                <div id="specialtyReportButtons">
                    <!-- L1 Monitor button will be added here by JS -->
                </div>
                 <hr>
                 <button class="btn btn-dark w-100" id="generatePdfBtn">Download Detailed PDF Summary</button>
            </div>

            <!-- Tab Navigation -->
            <ul class="nav nav-tabs" id="mainTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="dashboard-tab" data-bs-toggle="tab" data-bs-target="#dashboard-pane" type="button" role="tab">Full Analytics Dashboard</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="work-queue-tab" data-bs-toggle="tab" data-bs-target="#work-queue-pane" type="button" role="tab">Operational Work Queue</button>
                </li>
            </ul>

            <!-- Tab Content -->
            <div class="tab-content border border-top-0 p-3 bg-white">
                <!-- Dashboard Pane -->
                <div class="tab-pane fade show active" id="dashboard-pane" role="tabpanel">
                    <div id="executive-summary-section" class="dashboard-section">
                        <h2 class="h4 text-muted mb-4" style="font-weight: 300;">Executive Summary</h2>
                        <div class="row g-4 mb-5" id="executive-summary-cards"></div>
                    </div>
                </div>

                <!-- Work Queue Pane -->
                <div class="tab-pane fade" id="work-queue-pane" role="tabpanel">
                    <div class="section-header"><h2 class="h5">Intelligent Operational Work Queue</h2></div>
                    <div class="card p-3 mb-3 bg-light border-0">
                        <label for="categoryFilter" class="form-label fw-bold">Filter by Category</label>
                        <select id="categoryFilter" class="form-select">
                            <option value="all" selected>All Actionable Categories</option>
                        </select>
                    </div>
                    <div class="table-responsive">
                        <table class="table table-striped table-hover" id="work-queue-table">
                            <thead>
                                <tr>
                                    <th data-sort="priorityScore">Priority Score</th>
                                    <th data-sort="category">Category</th>
                                    <th data-sort="source">Source</th>
                                    <th data-sort="teamName">Assigned Team</th>
                                    <th>Prov Ops Team Mbr</th>
                                    <th data-sort="w9Attached">W9 Attached?</th>
                                    <th data-sort="tinHasW9InPV">TIN Has W9?</th>
                                    <th data-sort="pvApproved">Approved in PV?</th>
                                    <th data-sort="pvSource">PV Source/Notes</th>
                                    <th>PV Updated (Y/N)</th>
                                    <th>Notes</th>
                                    <th data-sort="claimId">Claim ID</th>
                                    <th data-sort="age">Age (Days)</th>
                                    <th data-sort="netPayment">Amount at Risk</th>
                                    <th data-sort="providerName">Billing Provider</th>
                                </tr>
                            </thead>
                            <tbody id="work-queue-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- Global Variables ---
        let allClaimsData = [];
        let aggregatedMetrics = {};
        let myCharts = {};
        let currentSort = { column: 'priorityScore', direction: 'desc' };
        let currentColumnMappings = {};
        let allConfigs = [];
        let allCategories = [];
        let teamReportConfigs = [];
        let clientRules = { editRules: [], noteRules: [] };

        const standardFields = [
             { key: 'claimId', displayName: 'Claim ID / Number' }, { key: 'age', displayName: 'Age (in days)' }, { key: 'netPayment', displayName: 'Net Payment Amount' }, { key: 'state', displayName: 'Claim State' }, { key: 'status', displayName: 'Claim Status' }, { key: 'networkStatus', displayName: 'Network Status' }, { key: 'providerName', displayName: 'Billing Provider Name' }, { key: 'edit', displayName: 'Claim Edits' }, { key: 'notes', displayName: 'Claim Notes' }, { key: 'totalCharges', displayName: 'Total Billed Amount' }, { key: 'dsnp', displayName: 'DSNP Status' }, { key: 'payer', displayName: 'Payer Name' }, { key: 'claimCategory', displayName: 'Category' }, { key: 'claimType', displayName: 'Claim Type' }, { key: 'receivedDate', displayName: 'Received Date' }, { key: 'billingProviderTaxId', displayName: 'Billing Provider Tax ID' }, { key: 'billingProviderNpi', displayName: 'Billing Provider NPI' }, { key: 'patientName', displayName: 'Patient Name' }, { key: 'subscriberId', displayName: 'Subscriber ID' }, { key: 'renderingProviderName', displayName: 'Rendering Provider Name' }, { key: 'renderingProviderNpi', displayName: 'Rendering Provider NPI' }, { key: 'dosFrom', displayName: 'Date of Service (From)' }, { key: 'dosTo', displayName: 'Date of Service (To)' }, { key: 'cleanAge', displayName: 'Clean Age' }, { key: 'pbpName', displayName: 'PBP Name' }, { key: 'planName', displayName: 'Plan Name' }, { key: 'activityLog', displayName: 'Activity Log Description' }, { key: 'activityUser', displayName: 'Activity Performed By' }, { key: 'activityDate', displayName: 'Activity Performed On' }
        ];
        
        const availableMetrics = [
            { key: 'count', displayName: 'Number of Claims' },
            { key: 'avgAge', displayName: 'Average Claim Age' },
            { key: 'avgCleanAge', displayName: 'Average Clean Age' }
        ];

        // --- SMART getVal FUNCTION ---
        const getVal = (claim, standardKey, mappings) => {
            const effectiveMappings = mappings || currentColumnMappings;
            const mappedKey = effectiveMappings[standardKey];
            return (mappedKey && claim[mappedKey] !== undefined) ? claim[mappedKey] : undefined;
        };
        
        // --- DYNAMIC CATEGORIZATION LOGIC ---
        function getClaimCategory(claim) {
            const notes = (getVal(claim, 'notes') || '').toLowerCase();
            const edit = getVal(claim, 'edit');
            
            const categoryMap = new Map(allCategories.map(cat => [cat.id, cat]));

            const editRule = clientRules.editRules.find(r => r.text === edit);
            if (editRule) {
                const category = categoryMap.get(editRule.category_id);
                if(category) return { ...category, category: category.category_name, source: 'Edit Rule' };
            }

            if (notes) {
                const sortedNoteRules = [...clientRules.noteRules].sort((a, b) => b.text.length - a.text.length);
                for (const noteRule of sortedNoteRules) {
                    if (notes.includes(noteRule.text)) {
                        const category = categoryMap.get(noteRule.category_id);
                        if(category) return { ...category, category: category.category_name, source: 'Note Rule' };
                    }
                }
            }
            return { category: 'Needs Triage', source: 'Default', team_name: 'Needs Assignment', send_to_l1_monitor: false };
        }

        // --- CONFIGURATION & DATA LOADING ---
        async function loadInitialData() {
            try {
                const [configsRes, categoriesRes, reportsRes] = await Promise.all([
                    fetch('/.netlify/functions/configurations'),
                    fetch('/.netlify/functions/categories'),
                    fetch('/.netlify/functions/team-report-configs')
                ]);
                allConfigs = await configsRes.json();
                allCategories = await categoriesRes.json();
                teamReportConfigs = await reportsRes.json();
                const configSelector = document.getElementById('configSelector');
                configSelector.innerHTML = '<option value="">Load a saved configuration...</option>';
                allConfigs.forEach(config => configSelector.add(new Option(config.config_name, config.id)));
            } catch (error) {
                console.error('Error loading initial dashboard data:', error);
                alert('Failed to load critical dashboard configurations. Please refresh the page.');
            }
        }

        document.getElementById('configSelector').addEventListener('change', async (e) => {
            const selectedId = e.target.value;
            const selectedConfig = allConfigs.find(c => c.id == selectedId);
            clientRules = { editRules: [], noteRules: [] };
            
            if (selectedConfig?.config_data) {
                document.getElementById('clientName').value = selectedConfig.config_data.clientName || '';
                currentColumnMappings = selectedConfig.config_data.columnMappings || {};
                
                try {
                    const [editRes, noteRes] = await Promise.all([
                        fetch(`/.netlify/functions/client-rules?type=edit&config_id=${selectedId}`),
                        fetch(`/.netlify/functions/client-rules?type=note&config_id=${selectedId}`)
                    ]);
                    if (!editRes.ok || !noteRes.ok) throw new Error('Failed to fetch rules.');
                    clientRules.editRules = await editRes.json();
                    clientRules.noteRules = await noteRes.json();
                } catch (error) {
                    console.error('Error loading client-specific rules:', error);
                    alert('Could not load categorization rules. Categorization may be incorrect.');
                }
                if (allClaimsData.length > 0) handleFile(null, true); 
            } else {
                document.getElementById('clientName').value = '';
                currentColumnMappings = {};
            }
        });

        // --- MAIN FILE HANDLING AND PROCESSING LOGIC ---
        function handleFile(event, isReprocessing = false) {
            if (!isReprocessing && !event.target.files[0]) return;
            if (!document.getElementById('configSelector').value) {
                alert("Please select a report configuration first.");
                if (event) event.target.value = "";
                return;
            }
            const processAndRender = (data) => {
                try {
                    const processedData = analyzeAndProcessClaims(data);
                    allClaimsData = processedData.claims;
                    aggregatedMetrics = processedData.metrics;
                    renderDashboard(allClaimsData, aggregatedMetrics);
                    populateCategoryFilter(allClaimsData);
                    document.getElementById('providerReportFile').disabled = false;
                    renderWorkQueue(allClaimsData);
                    document.getElementById('dashboardContent').style.display = 'block';
                } catch (error) { console.error("An error occurred during file processing:", error); alert("Failed to process the file. Check console for details."); }
            };
            if (isReprocessing) {
                processAndRender(allClaimsData.map(c => c.original));
                return;
            }
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                processAndRender(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]));
            };
            reader.readAsArrayBuffer(file);
        }
        
        function handleProviderFile(event) {
            const file = event.target.files[0];
            if (!file || allClaimsData.length === 0) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                const providerData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]);
                const headers = Object.keys(providerData[0] || {});
                const claimIdKey = headers.find(h => h.toLowerCase().includes('claim id'));
                if(!claimIdKey) return alert("Could not find a 'Claim ID' column in the Provider Verification report.");
                const w9AttachedKey = headers.find(h => h.toLowerCase().includes('w9 attached'));
                const isApprovedKey = headers.find(h => h.toLowerCase().includes('isapproved in pv'));
                const sourceKey = headers.find(h => h.toLowerCase().includes('source in pv'));
                const providerMap = new Map(providerData.map(row => [row[claimIdKey]?.toString(), { w9Attached: row[w9AttachedKey] || 'N/A', pvApproved: row[isApprovedKey] || 'N/A', pvSource: row[sourceKey] || '' }]));
                allClaimsData.forEach(claim => Object.assign(claim, providerMap.get(claim.claimId)));
                if(currentColumnMappings.billingProviderTaxId) {
                    const tinStatusMap = new Map();
                    allClaimsData.forEach(claim => {
                        const tin = getVal(claim.original, 'billingProviderTaxId');
                        if (tin && claim.w9Attached?.toString().trim().toUpperCase() === 'YES') tinStatusMap.set(tin, 'YES');
                    });
                    allClaimsData.forEach(claim => {
                        const tin = getVal(claim.original, 'billingProviderTaxId');
                        claim.tinHasW9InPV = tin && tinStatusMap.has(tin) ? 'YES' : 'NO';
                    });
                }
                renderWorkQueue(allClaimsData);
                alert(`Successfully merged data from ${providerMap.size} records.`);
            };
            reader.readAsArrayBuffer(file);
        }

        function analyzeAndProcessClaims(data) {
            const metrics = { totalClaims: 0, totalNetPayment: 0, claimsByStatus: {}, providerCounts: {} };
            const actionableStates = ['PEND', 'ONHOLD', 'MANAGEMENTREVIEW'];
            const claims = data.map(rawClaim => {
                const processedClaim = {
                    claimId: getVal(rawClaim, 'claimId') || 'N/A',
                    state: (getVal(rawClaim, 'state') || 'UNKNOWN').toString().toUpperCase().trim(),
                    status: (getVal(rawClaim, 'status') || 'UNKNOWN').toString().toUpperCase().trim(),
                    age: parseInt(getVal(rawClaim, 'age') || 0),
                    netPayment: parseFloat(getVal(rawClaim, 'netPayment') || 0),
                    providerName: getVal(rawClaim, 'providerName') || 'Unknown',
                    tinHasW9InPV: 'N/A',
                    original: rawClaim,
                };
                metrics.totalClaims++;
                if (!isNaN(processedClaim.netPayment)) metrics.totalNetPayment += processedClaim.netPayment;
                metrics.claimsByStatus[processedClaim.status] = (metrics.claimsByStatus[processedClaim.status] || 0) + 1;

                processedClaim.isActionable = actionableStates.includes(processedClaim.state);
                if (processedClaim.isActionable) {
                    const categoryInfo = getClaimCategory(rawClaim);
                    Object.assign(processedClaim, categoryInfo);
                    processedClaim.priorityScore = getPriorityScore(processedClaim);
                } else {
                    processedClaim.category = 'N/A';
                    processedClaim.team_name = 'N/A';
                    processedClaim.priorityScore = -1;
                }
                return processedClaim;
            });
            return { claims, metrics };
        }
        
        function getPriorityScore(claim) {
            const totalCharges = parseFloat(getVal(claim.original, 'totalCharges') || 0);
            const age = parseInt(claim.age || 0);
            let score = (totalCharges / 500) + (age * 1.5);
            if (claim.status === 'DENY') score += 100;
            return Math.round(score);
        }

        function renderDashboard(claims, metrics) {
            const fNum = (num) => num.toLocaleString('en-US');
            const fCur = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
            document.getElementById('executive-summary-cards').innerHTML = `
                <div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100"><div class="metric-label">TOTAL CLAIMS</div><div class="metric-value">${fNum(metrics.totalClaims)}</div></div></div>
                <div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100"><div class="metric-label">TOTAL NET PAYMENT</div><div class="metric-value">${fCur(metrics.totalNetPayment)}</div></div></div>
                <div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100"><div class="metric-label">PENDING</div><div class="metric-value">${fNum(metrics.claimsByStatus['PEND'] || 0)}</div></div></div>
                <div class="col-md-6 col-lg-3 mb-4"><div class="card dashboard-card h-100"><div class="metric-label">DENIED</div><div class="metric-value">${fNum(metrics.claimsByStatus['DENY'] || 0)}</div></div></div>
            `;
            populateDownloadButtons(claims);
        }

        function populateCategoryFilter(claims) {
            const filter = document.getElementById('categoryFilter');
            const categories = [...new Set(claims.filter(c => c.isActionable).map(c => c.category))];
            filter.innerHTML = '<option value="all" selected>All Actionable Categories</option>';
            categories.sort().forEach(cat => filter.add(new Option(cat, cat)));
        }

        function renderWorkQueue(claims) {
            const selectedCategory = document.getElementById('categoryFilter').value;
            let actionable = claims.filter(c => c.isActionable && (selectedCategory === 'all' || c.category === selectedCategory));
            actionable.sort((a, b) => (b[currentSort.column] || 0) - (a[currentSort.column] || 0) * (currentSort.direction === 'asc' ? 1 : -1));
            document.getElementById('work-queue-body').innerHTML = actionable.map(claim =>
                `<tr>
                    <td>${claim.priorityScore}</td> <td>${claim.category || 'N/A'}</td> <td>${claim.source || 'N/A'}</td> <td>${claim.team_name || 'N/A'}</td>
                    <td></td> <td>${claim.w9Attached || ''}</td> <td>${claim.tinHasW9InPV || 'N/A'}</td> <td>${claim.pvApproved || ''}</td>
                    <td>${claim.pvSource || ''}</td> <td></td> <td></td> <td>${claim.claimId || 'N/A'}</td> <td>${claim.age || 0}</td>
                    <td>$${(claim.netPayment || 0).toFixed(2)}</td> <td>${claim.providerName || 'N/A'}</td>
                </tr>`
            ).join('');
        }

        function populateDownloadButtons(claims) {
            const teamContainer = document.getElementById('teamReportButtons');
            const specialtyContainer = document.getElementById('specialtyReportButtons');
            const actionableClaims = claims.filter(c => c.isActionable);
            const teams = [...new Set(actionableClaims.map(c => c.team_name).filter(Boolean))];
            teamContainer.innerHTML = teams.length === 0 ? '<p class="text-muted">No actionable claims found for any team.</p>' : '';
            teams.sort().forEach(teamName => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-success';
                btn.innerHTML = `<i class="bi bi-download"></i> Download ${teamName} Report`;
                btn.onclick = () => downloadTeamReport(teamName, actionableClaims);
                teamContainer.appendChild(btn);
            });
            specialtyContainer.innerHTML = '';
            const l1MonitorClaims = actionableClaims.filter(c => c.send_to_l1_monitor);
            if(l1MonitorClaims.length > 0) {
                const btn = document.createElement('button');
                btn.className = 'btn btn-info';
                btn.innerHTML = `<i class="bi bi-clipboard-data"></i> Download L1 Monitor Report (${l1MonitorClaims.length} items)`;
                btn.onclick = () => downloadL1MonitorReport(l1MonitorClaims);
                specialtyContainer.appendChild(btn);
            }
        }
        
        // --- CORRECTED `downloadTeamReport` FUNCTION ---
        function downloadTeamReport(teamName, allActionableClaims) {
            const teamClaims = allActionableClaims.filter(c => c.team_name === teamName);
            if (teamClaims.length === 0) return alert(`No claims for team: ${teamName}`);

            const wb = XLSX.utils.book_new();
            const today = new Date().toISOString().slice(0, 10);

            // Create a map of standard field keys to their display names for easy header lookup
            const standardFieldMap = new Map(standardFields.map(f => [f.key, f.displayName]));
            availableMetrics.forEach(m => standardFieldMap.set(m.key, m.displayName));

            const claimsByReportFormat = teamClaims.reduce((acc, claim) => {
                // Ensure IDs are treated as numbers for a reliable lookup.
                const teamId = parseInt(claim.team_id, 10);
                const categoryId = parseInt(claim.id, 10); // This is the category's DB ID

                // Robust lookup for the custom report configuration
                const customReportConfig = (teamId && categoryId)
                    ? teamReportConfigs.find(rc => rc.team_id === teamId && rc.category_id === categoryId)
                    : null;

                const key = customReportConfig ? `config_${customReportConfig.id}` : (claim.category || 'Uncategorized');
                (acc[key] = acc[key] || []).push(claim);
                return acc;
            }, {});

            for (const key in claimsByReportFormat) {
                const claimsInGroup = claimsByReportFormat[key];
                const categoryName = claimsInGroup[0].category;
                let reportData = [];
                let headers = [];

                if (key.startsWith('config_')) {
                    const configId = parseInt(key.split('_')[1], 10);
                    const customReportConfig = teamReportConfigs.find(rc => rc.id === configId);
                    
                    if (customReportConfig && customReportConfig.report_config_data) {
                        const { dataColumns = [], metrics = [], groupBy = [], sourceConfigId } = customReportConfig.report_config_data;
                        const sourceConfig = allConfigs.find(c => c.id == sourceConfigId);
                        
                        if (!sourceConfig) {
                            reportData = claimsInGroup.map(claim => ({ ...claim.original, 'ERROR': `Could not find Source Config ID ${sourceConfigId}` }));
                        } else {
                            const reportMappings = sourceConfig.config_data.columnMappings;
                            // Determine the final list of columns for the report
                            const allColumnKeys = [...new Set([...dataColumns, ...groupBy, ...metrics])];
                            headers = allColumnKeys.map(k => standardFieldMap.get(k) || k);

                            // AGGREGATED REPORT (If groupBy is used)
                            if (groupBy.length > 0) {
                                const aggregatedData = new Map();
                                claimsInGroup.forEach(claim => {
                                    const groupByKey = groupBy.map(stdKey => getVal(claim.original, stdKey, reportMappings) || 'N/A').join('|');
                                    
                                    if (!aggregatedData.has(groupByKey)) {
                                        const initialRow = {};
                                        // Include all selected data columns, not just groupBy columns
                                        [...new Set([...dataColumns, ...groupBy])].forEach(stdKey => {
                                            const header = standardFieldMap.get(stdKey) || stdKey;
                                            initialRow[header] = getVal(claim.original, stdKey, reportMappings) || 'N/A';
                                        });
                                        initialRow._metrics = { count: 0, totalAge: 0, totalCleanAge: 0 };
                                        aggregatedData.set(groupByKey, initialRow);
                                    }
                                    
                                    const group = aggregatedData.get(groupByKey);
                                    group._metrics.count++;
                                    group._metrics.totalAge += (parseInt(getVal(claim.original, 'age', reportMappings), 10) || 0);
                                    group._metrics.totalCleanAge += (parseInt(getVal(claim.original, 'cleanAge', reportMappings), 10) || 0);
                                });

                                reportData = Array.from(aggregatedData.values()).map(group => {
                                    const finalRow = { ...group };
                                    if (metrics.includes('count')) finalRow[standardFieldMap.get('count')] = group._metrics.count;
                                    if (metrics.includes('avgAge')) finalRow[standardFieldMap.get('avgAge')] = group._metrics.count > 0 ? (group._metrics.totalAge / group._metrics.count).toFixed(1) : 0;
                                    if (metrics.includes('avgCleanAge')) finalRow[standardFieldMap.get('avgCleanAge')] = group._metrics.count > 0 ? (group._metrics.totalCleanAge / group._metrics.count).toFixed(1) : 0;
                                    delete finalRow._metrics;
                                    return finalRow;
                                });

                            } 
                            // DETAILED REPORT (If no groupBy is used)
                            else {
                                reportData = claimsInGroup.map(claim => {
                                    const row = {};
                                    allColumnKeys.forEach(stdKey => {
                                        const header = standardFieldMap.get(stdKey) || stdKey;
                                        row[header] = getVal(claim.original, stdKey, reportMappings);
                                    });
                                    return row;
                                });
                            }
                        }
                    }
                } else {
                    // FALLBACK for categories without a configured report
                    reportData = claimsInGroup.map(claim => ({ ...claim.original, 'Category': claim.category, 'Assigned Team': claim.team_name }));
                }

                if (reportData.length > 0) {
                    reportData.forEach(row => { row['Prov Ops Team Mbr'] = ''; row['PV Updated (Y/N)'] = ''; row['Notes'] = ''; });
                    const ws = XLSX.utils.json_to_sheet(reportData);
                    const safeSheetName = categoryName.replace(/[\/\\?*\[\]]/g, '').substring(0, 31);
                    XLSX.utils.book_append_sheet(wb, ws, safeSheetName);
                }
            }

            if (wb.SheetNames.length > 0) {
                wb.SheetNames.sort();
                const clientName = document.getElementById('clientName').value.trim().replace(/ /g, '_') || 'Client';
                const safeTeamName = teamName.replace(/ /g, '_');
                XLSX.writeFile(wb, `${clientName}_${safeTeamName}_Report_${today}.xlsx`);
            } else {
                alert(`No data available to generate a report for team: ${teamName}`);
            }
        }

        function downloadL1MonitorReport(l1Claims) {
            const today = new Date().toISOString().slice(0, 10);
            const clientName = document.getElementById('clientName').value.trim().replace(/ /g, '_') || 'Client';
            const reportData = l1Claims.map(claim => ({
                'Claim ID': claim.claimId, 'Category': claim.category, 'Assigned Team': claim.team_name, 'Age (Days)': claim.age,
                'Amount at Risk': claim.netPayment, 'Billing Provider Name': claim.providerName,
                'Billing Provider Tax ID': getVal(claim.original, 'billingProviderTaxId'),
                'TIN Has W9 in PV': claim.tinHasW9InPV, 'Claim-Specific W9 Attached': claim.w9Attached, 'Claim-Specific PV Notes': claim.pvSource
            }));
            const ws = XLSX.utils.json_to_sheet(reportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'L1 Monitor Items');
            XLSX.writeFile(wb, `${clientName}_L1_Monitor_Report_${today}.xlsx`);
        }
        
        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', loadInitialData);
        document.getElementById('reportFile').addEventListener('change', (e) => handleFile(e, false));
        document.getElementById('providerReportFile').addEventListener('change', handleProviderFile);
        document.getElementById('generatePdfBtn').addEventListener('click', () => alert('PDF generation is a complex feature and is stubbed out for this example.'));
        document.getElementById('work-queue-table').querySelector('thead').addEventListener('click', (e) => {
            const header = e.target.closest('th');
            if (header?.dataset.sort) {
                const sortKey = header.dataset.sort;
                currentSort.direction = (currentSort.column === sortKey && currentSort.direction === 'desc') ? 'asc' : 'desc';
                currentSort.column = sortKey;
                renderWorkQueue(allClaimsData);
            }
        });
        document.getElementById('categoryFilter').addEventListener('change', () => renderWorkQueue(allClaimsData));

    </script>
</body>
</html>
