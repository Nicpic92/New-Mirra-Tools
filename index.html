<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Claims Dashboard & Analytics Engine</title>
    <!-- Bootstrap 5 for Layout and Styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons for Buttons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <!-- Chart.js for Graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- SheetJS (XLSX) & PapaParse (CSV) Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <!-- Libraries for Advanced PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <style>
        :root { --primary-color: #0d6efd; --secondary-color: #f8f9fa; }
        body { background-color: white; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
        .dashboard-card { border-radius: 0.375rem; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); border: 1px solid #dee2e6; border-left-width: 4px; padding: 1.25rem; }
        .metric-value { font-size: 2.25rem; font-weight: 700; color: #212529; }
        .metric-label { font-size: 0.8rem; font-weight: 600; text-transform: uppercase; }
        .chart-container { min-height: 380px; background-color: white; padding: 20px; border-radius: 0.5rem; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); }
        .section-header { background-color: #465a6c; color: white; padding: 8px 15px; border-radius: 0.25rem; margin-bottom: 1rem; }
        .aging-table-header { background-color: #465a6c; color: white; padding: 8px 15px; border-radius: 0.25rem; font-size: 1.1rem; margin-top: 1rem; }
        .aging-table thead { background-color: #f1f4f6; }
        #dashboardContent { display: none; }
        #work-queue-table th { background-color: #005A9C; color: white; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container-fluid p-4">
        <!-- Header Section -->
        <header class="mb-4 d-flex justify-content-between align-items-center">
            <div>
                <img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAZCAYAAAC115MjAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARRSURBVChTPZf/a9NXHMc/520kLg3L+m2DIsO2pKGv+i8u/AN2d9FNHHRwdr3sDqYru93VzU5XV7c3o05FmJ2YqW432B/A68qKVgN6KVoLqS11475c7nN/eR5+25f6eRy9Dw79dE/u+RzP53O+z+f+uD/wPz3uA1fC42BxeBQ8DheDh8HDZfD4WIKzVqv18wDXtrY25s2bx2tra4kX+n54s/M64N/gH5EHgP/7xGQSqe7u7lYhV3Z2Nua9vLzg6enpiF5fXxs/pW/gT+BvIF8A/gb+D3yKq4s/cIX2z/sT29vbH9s2fPLkSbS2trb68OHDH2uVSqXgVqv13wC/AwCgVCrl6unpATs7O9f5z3kK2d/fD6WlpQ9fXV3t5b3LsbGx/Nra2pIbnJ+f/w+Qy+W0W61Wqf56vR729/f/kYmRkZGMYwDwwv17eno251z5dCAQyC0Wi3k/Pz87f7+A0+m0f3Nzc3s4HF65yWZycnL24x+5XC4AIBqNQgUCAcDOzs7O1tZWvL+/P/F+f38/xGIxDAwM/JpZ1GAwSA+HQ6pQKMjJkycxsW6r1UoFAgEMDAwA1NbWwuLiYgwODsLl5eXoQSAQAAgEAhgYGPg1s6jBYJCeSqV0WCwWub+/H/f39+P8/HyPzwCgvb0dAICJiQmcTqflM2tO7+/vTxx+/vx5jMVi4OXl5X9+SAYGBgCcnZ2BIBAIkMvlYDAY/s1sKhgMkobD4Wr5fD6lVqs1Xl5exvX19b/X19e/19fX/4/5AOTz+QCA6urqIC4uDoFAIFqvzS0xMTHxh/sB+Xw+FkqlUqvVajWfz4eBgQF+s1+1Gg01GAxSTqcTYTabEY/HYWdnZ2fr6uoS4z09PUfUajUrVqsVn88nAODs7AxxDeDk5IQpFAopFou1ZtfrNb7pSRQKEQ8fPhzL5/MBnJ2dgXg8/jX/Xzkcju/j8VguFotzTafTmUwmf3Z3d+f0ej0Wi8XpNEql0h+LRYIgCGf39/fLZ8kIBAKEgYGBFysUCgCAi4sLfL58eXl5GSA+Pj6W0+l0Xl5expw1qMVisVgs5tY8Gg22tbVlX1hY+EVFRUVnZ2fBbrd/+3a7/bN+s+v1erFcrvzr6+v/JpPJ4J35xIkTJ3p6eiKz2Xxar9e/+eXl5U8sFitfX1+PcXJyYtq2bQ+n0znnzMxMkMvlcnp6+o/v7+/r7e2t1Wr1u/b29n+1tbXlOI4vW1paHh8fD7lcrtfr9etLS0ufXlxc/PNf319fX//P/wKkUql0OByW0Wj8sFqtYLPZH38+n/+0XC6/n0wmP8lk8s/Z7HY7KBSK/1wul+8qlcq/Vqv1XygU/uX19fUvnU7n/Uaj8f9KpfI/oVDoX6PROBgM/m9sQ+w7g/8/l8sVsNls/qJSqb+lUumPFy9efF6r1T6bzeZ/stnsv6vV6h/X6/X/z6f3k0Ufgs2LwOLwCHgcrAaPw8Pgg/AhOM4X/n/D31/B/gU1Fh0wWlC6GgAAAABJRU5ErkJggg==' alt="Mirra Logo" style="height: 24px; margin-bottom: 10px;" id="logoImage">
                <h1 class="display-6" style="color: #0d6efd;" id="mainTitle">Claims Processing Daily Dashboard</h1>
            </div>
            <a href="/admin.html" class="btn btn-outline-primary">Go to Admin Console</a>
        </header>

        <div id="dashboardOptions">
            <div class="pdf-options card p-3 mb-4">
                <h5 class="card-title fw-bold">1. Report Options</h5>
                <div class="row align-items-end">
                    <div class="col-md-6 mb-3">
                        <label for="configSelector" class="form-label small fw-bold">Select Report Configuration</label>
                        <select class="form-select form-select-sm" id="configSelector">
                            <option value="">Loading configurations...</option>
                        </select>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="clientName" class="form-label small fw-bold">Client Name</label>
                        <input type="text" class="form-control form-select-sm" id="clientName" placeholder="Select a configuration" readonly>
                    </div>
                </div>
            </div>
        </div>

        <!-- File Input Section -->
        <div class="card p-3 mb-4 bg-light border-0">
            <h5 class="card-title fw-bold">2. Upload Claims Data</h5>
            <label for="reportFile" class="form-label">Select an XLSX or CSV file to begin analysis.</label>
            <input class="form-control" type="file" id="reportFile" accept=".xlsx, .csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
        </div>
        
        <div id="dashboardContent" style="display: none;">
            <!-- Download Buttons Section -->
            <div class="card p-3 mb-4">
                <h5 class="card-title fw-bold">3. Download Reports</h5>
                <div id="teamReportButtons" class="d-grid gap-2 d-md-flex">
                    <p class="text-muted">Process a file to generate download buttons for each team.</p>
                </div>
                 <hr>
                 <button class="btn btn-dark w-100" id="generatePdfBtn">Download Detailed PDF Summary</button>
            </div>

            <!-- Tab Navigation -->
            <ul class="nav nav-tabs" id="mainTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="dashboard-tab" data-bs-toggle="tab" data-bs-target="#dashboard-pane" type="button" role="tab">Full Analytics Dashboard</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="work-queue-tab" data-bs-toggle="tab" data-bs-target="#work-queue-pane" type="button" role="tab">Operational Work Queue</button>
                </li>
            </ul>

            <!-- Tab Content -->
            <div class="tab-content border border-top-0 p-3 bg-white">
                <!-- Dashboard Pane -->
                <div class="tab-pane fade show active" id="dashboard-pane" role="tabpanel">
                    <div id="executive-summary-section" class="dashboard-section">
                        <h2 class="h4 text-muted mb-4" style="font-weight: 300;">Executive Summary</h2>
                        <div class="row g-4 mb-5" id="executive-summary-cards"></div>
                    </div>
                </div>

                <!-- Work Queue Pane -->
                <div class="tab-pane fade" id="work-queue-pane" role="tabpanel">
                    <div class="section-header"><h2 class="h5">Intelligent Operational Work Queue</h2></div>
                    <div class="card p-3 mb-3 bg-light border-0">
                        <label for="categoryFilter" class="form-label fw-bold">Filter by Category</label>
                        <select id="categoryFilter" class="form-select">
                            <option value="all" selected>All Actionable Categories</option>
                        </select>
                    </div>
                    <div class="table-responsive">
                        <table class="table table-striped table-hover" id="work-queue-table">
                            <thead>
                                <tr>
                                    <th data-sort="priorityScore">Priority Score</th>
                                    <th data-sort="category">Category</th>
                                    <th data-sort="source">Source</th>
                                    <th data-sort="teamName">Assigned Team</th>
                                    <th>Prov Ops Team Mbr</th>
                                    <th>PV Updated (Y/N)</th>
                                    <th>Notes</th>
                                    <th data-sort="claimId">Claim ID</th>
                                    <th data-sort="age">Age (Days)</th>
                                    <th data-sort="netPayment">Amount at Risk</th>
                                    <th data-sort="providerName">Billing Provider</th>
                                </tr>
                            </thead>
                            <tbody id="work-queue-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- Global Variables ---
        let allClaimsData = [];
        let aggregatedMetrics = {};
        let myCharts = {};
        let currentSort = { column: 'priorityScore', direction: 'desc' };
        let currentColumnMappings = {};
        let allConfigs = [];
        let categorizationConfig = {
            editRulesMap: new Map(),
            noteRulesMap: new Map()
        };

        // --- SMART getVal FUNCTION ---
        const getVal = (claim, standardKey) => {
            const mappedKey = currentColumnMappings[standardKey];
            return (mappedKey && claim[mappedKey] !== undefined) ? claim[mappedKey] : undefined;
        };

        // --- DYNAMIC CATEGORIZATION LOGIC ---
        async function loadCategorizationConfig() {
            try {
                const response = await fetch('/.netlify/functions/get-categorization-config');
                if (!response.ok) throw new Error('Failed to load categorization config');
                const config = await response.json();
                categorizationConfig.editRulesMap = new Map(config.editRules.map(r => [r.edit_text, { category: r.category_name, teamId: r.team_id, teamName: r.team_name }]));
                categorizationConfig.noteRulesMap = new Map(config.noteRules.map(r => [r.note_keyword, { category: r.category_name, teamId: r.team_id, teamName: r.team_name }]));
            } catch (error) {
                console.error("Could not load categorization rules:", error);
            }
        }

        function getClaimCategory(claim) {
            const notes = (getVal(claim, 'notes') || '').toLowerCase();
            const edit = getVal(claim, 'edit');

            if (edit && categorizationConfig.editRulesMap.has(edit)) {
                const rule = categorizationConfig.editRulesMap.get(edit);
                return { ...rule, source: 'Edit Rule' };
            }

            if (notes) {
                for (const [keyword, rule] of categorizationConfig.noteRulesMap.entries()) {
                    if (notes.includes(keyword)) {
                        return { ...rule, source: 'Note Rule' };
                    }
                }
            }
            
            const totalCharges = parseFloat(getVal(claim, 'totalCharges') || 0);
            if (totalCharges > 50000) return { category: 'On Hold: High Dollar Review', source: 'Fallback', teamName: 'Needs Assignment' };
            if (notes.includes('duplicate') || (edit || '').toLowerCase().includes('duplicate')) return { category: 'On Hold: Duplicate', source: 'Fallback', teamName: 'Needs Assignment' };
            
            return { category: 'Needs Triage', source: 'Default', teamName: 'Needs Assignment' };
        }

        // --- CONFIGURATION & EVENT LISTENERS ---
        async function populateConfigSelector() {
            try {
                const response = await fetch('/.netlify/functions/configurations');
                const configs = await response.json();
                allConfigs = configs;
                const configSelector = document.getElementById('configSelector');
                configSelector.innerHTML = '<option value="">Load a saved configuration...</option>';
                configs.forEach(config => {
                    configSelector.add(new Option(config.config_name, config.id));
                });
            } catch (error) {
                console.error('Error populating configurations:', error);
            }
        }

        document.getElementById('configSelector').addEventListener('change', (e) => {
            const selectedId = parseInt(e.target.value, 10);
            const selectedConfig = allConfigs.find(c => c.id === selectedId);
            const clientNameInput = document.getElementById('clientName');
            
            if (selectedConfig?.config_data) {
                clientNameInput.value = selectedConfig.config_data.clientName || '';
                currentColumnMappings = selectedConfig.config_data.columnMappings || {};
                if (allClaimsData.length > 0) handleFile(null, true); 
            } else {
                clientNameInput.value = '';
                currentColumnMappings = {};
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('reportFile').addEventListener('change', (e) => handleFile(e, false));
            document.getElementById('generatePdfBtn').addEventListener('click', generateStructuredPDF);
            document.getElementById('work-queue-table').querySelector('thead').addEventListener('click', (e) => {
                const header = e.target.closest('th');
                if (header?.dataset.sort) {
                    const sortKey = header.dataset.sort;
                    currentSort.direction = (currentSort.column === sortKey && currentSort.direction === 'desc') ? 'asc' : 'desc';
                    currentSort.column = sortKey;
                    renderWorkQueue(allClaimsData);
                }
            });
            document.getElementById('categoryFilter').addEventListener('change', () => renderWorkQueue(allClaimsData));
            
            populateConfigSelector();
            loadCategorizationConfig();
        });

        // --- MAIN FILE HANDLING AND PROCESSING LOGIC ---
        function handleFile(event, isReprocessing = false) {
            if (!isReprocessing && !event.target.files[0]) return;
            
            if (!document.getElementById('configSelector').value) {
                alert("Please select a report configuration first.");
                if (event) event.target.value = "";
                return;
            }

            const processAndRender = (data) => {
                try {
                    const processedData = analyzeAndProcessClaims(data);
                    allClaimsData = processedData.claims;
                    aggregatedMetrics = processedData.metrics;
                    renderDashboard(allClaimsData, aggregatedMetrics);
                    populateCategoryFilter(allClaimsData);
                    renderWorkQueue(allClaimsData);
                    document.getElementById('dashboardContent').style.display = 'block';
                } catch (error) {
                    console.error("An error occurred during file processing:", error);
                    alert("Failed to process the file. Check console for details.");
                }
            };

            if (isReprocessing) {
                processAndRender(allClaimsData.map(c => c.original));
                return;
            }

            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                if (file.name.endsWith('.csv')) {
                    Papa.parse(e.target.result, { header: true, skipEmptyLines: true, complete: (res) => processAndRender(res.data) });
                } else {
                    const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                    processAndRender(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]));
                }
            };
            file.name.endsWith('.csv') ? reader.readAsText(file) : reader.readAsArrayBuffer(file);
        }

        function analyzeAndProcessClaims(data) {
            const metrics = { totalClaims: 0, totalNetPayment: 0, claimsPend: 0, claimsDenied: 0, claimsByStatus: {}, claimsByState: {}, claimsByNetwork: {}, claimsByEdit: {}, providerCounts: { overall: {}, onhold: {}, mgmtreview: {} }};
            
            const createAgingTable = () => ({
                '0-20': { par: 0, nonpar: 0 },
                '21-27': { par: 0, nonpar: 0 },
                '28-30': { par: 0, nonpar: 0 },
                '31-59': { par: 0, nonpar: 0 },
                '60+': { par: 0, nonpar: 0 },
            });
            const agingData = {
                combined: createAgingTable(),
                active: createAgingTable(),
                prebatch: createAgingTable()
            };
            const getAgeBin = (age) => {
                if (age <= 20) return '0-20';
                if (age <= 27) return '21-27';
                if (age <= 30) return '28-30';
                if (age <= 59) return '31-59';
                return '60+';
            };
            const activeStatuses = ['PEND', 'DRAFT', 'ONHOLD', 'MANAGEMENTREVIEW', 'APPROVED'];

            const claims = data.map(rawClaim => {
                const processedClaim = {
                    state: (getVal(rawClaim, 'state') || 'UNKNOWN').toString().toUpperCase().trim(),
                    status: (getVal(rawClaim, 'status') || 'UNKNOWN').toString().toUpperCase().trim(),
                    age: parseInt(getVal(rawClaim, 'age') || 0),
                    netPayment: parseFloat(getVal(rawClaim, 'netPayment') || 0),
                    networkStatus: getVal(rawClaim, 'networkStatus') || 'Unknown',
                    edit: getVal(rawClaim, 'edit') || 'No Edits',
                    providerName: getVal(rawClaim, 'providerName') || 'Unknown',
                    claimId: getVal(rawClaim, 'claimId') || 'N/A',
                    original: rawClaim
                };

                metrics.totalClaims++;
                if (!isNaN(processedClaim.netPayment)) metrics.totalNetPayment += processedClaim.netPayment;
                if (processedClaim.status === 'PEND') metrics.claimsPend++;
                if (processedClaim.status === 'DENY') metrics.claimsDenied++;
                metrics.claimsByStatus[processedClaim.status] = (metrics.claimsByStatus[processedClaim.status] || 0) + 1;
                metrics.claimsByState[processedClaim.state] = (metrics.claimsByState[processedClaim.state] || 0) + 1;
                metrics.claimsByNetwork[processedClaim.networkStatus] = (metrics.claimsByNetwork[processedClaim.networkStatus] || 0) + 1;
                metrics.claimsByEdit[processedClaim.edit] = (metrics.claimsByEdit[processedClaim.edit] || 0) + 1;
                metrics.providerCounts.overall[processedClaim.providerName] = (metrics.providerCounts.overall[processedClaim.providerName] || 0) + 1;
                if (processedClaim.state === 'ONHOLD') metrics.providerCounts.onhold[processedClaim.providerName] = (metrics.providerCounts.onhold[processedClaim.providerName] || 0) + 1;
                if (processedClaim.state === 'MANAGEMENTREVIEW') metrics.providerCounts.mgmtreview[processedClaim.providerName] = (metrics.providerCounts.mgmtreview[processedClaim.providerName] || 0) + 1;
                
                const ageBin = getAgeBin(processedClaim.age);
                const networkKey = (processedClaim.networkStatus.toUpperCase().includes('NON') || processedClaim.networkStatus.toUpperCase().includes('OUT')) ? 'nonpar' : 'par';
                
                agingData.combined[ageBin][networkKey]++;
                if (activeStatuses.includes(processedClaim.status)) {
                    agingData.active[ageBin][networkKey]++;
                }
                if (processedClaim.state === 'PREBATCH') {
                    agingData.prebatch[ageBin][networkKey]++;
                }

                processedClaim.isActionable = ['PEND', 'ONHOLD', 'MANAGEMENTREVIEW'].includes(processedClaim.state);
                if (processedClaim.isActionable) {
                    const categoryInfo = getClaimCategory(rawClaim);
                    processedClaim.category = categoryInfo.category;
                    processedClaim.source = categoryInfo.source;
                    processedClaim.teamId = categoryInfo.teamId;
                    processedClaim.teamName = categoryInfo.teamName;
                    processedClaim.priorityScore = getPriorityScore(processedClaim);
                } else {
                    processedClaim.category = 'N/A';
                    processedClaim.source = 'N/A';
                    processedClaim.teamName = 'N/A';
                    processedClaim.priorityScore = -1;
                }
                return processedClaim;
            });
            
            const getTop10 = (counts, filterKey = null) => Object.entries(counts).filter(([k]) => k !== filterKey).sort(([, a], [, b]) => b - a).slice(0, 10).reduce((acc, [l, d]) => (acc.labels.push(l), acc.data.push(d), acc), { labels: [], data: [] });
            metrics.topEdits = getTop10(metrics.claimsByEdit, 'No Edits');
            metrics.topProvidersOverall = getTop10(metrics.providerCounts.overall);
            metrics.topProvidersOnHold = getTop10(metrics.providerCounts.onhold);
            metrics.topProvidersMgmtReview = getTop10(metrics.providerCounts.mgmtreview);
            
            const processSimpleTable = (counts) => {
                const sorted = Object.entries(counts).sort(([,a],[,b]) => b - a);
                return {
                    labels: sorted.map(item => item[0]),
                    data: sorted.map(item => item[1])
                };
            };
            metrics.claimsByFinalStatus = processSimpleTable(metrics.claimsByStatus);
            metrics.claimsByWorkflowState = processSimpleTable(metrics.claimsByState);

            const finalizeAgingTable = (tableData) => {
                const final = { bins: {}, totals: { par: 0, nonpar: 0, grand: 0 }};
                for (const bin in tableData) {
                    const par = tableData[bin].par;
                    const nonpar = tableData[bin].nonpar;
                    final.bins[bin] = { par, nonpar, total: par + nonpar };
                    final.totals.par += par;
                    final.totals.nonpar += nonpar;
                }
                final.totals.grand = final.totals.par + final.totals.nonpar;
                const sixtyPlusPar = final.bins['60+']?.par || 0;
                const sixtyPlusNonPar = final.bins['60+']?.nonpar || 0;
                final.bins['60+ Percent'] = {
                    par: final.totals.par > 0 ? ((sixtyPlusPar / final.totals.par) * 100).toFixed(1) + '%' : '0.0%',
                    nonpar: final.totals.nonpar > 0 ? ((sixtyPlusNonPar / final.totals.nonpar) * 100).toFixed(1) + '%' : '0.0%',
                    total: final.totals.grand > 0 ? (((sixtyPlusPar + sixtyPlusNonPar) / final.totals.grand) * 100).toFixed(1) + '%' : '0.0%'
                };
                return final;
            };
            metrics.agingCombined = finalizeAgingTable(agingData.combined);
            metrics.agingActive = finalizeAgingTable(agingData.active);
            metrics.agingPrebatch = finalizeAgingTable(agingData.prebatch);

            const selectedConfigId = parseInt(document.getElementById('configSelector').value, 10);
            const config = allConfigs.find(c => c.id === selectedConfigId);
            const customWidgets = config?.config_data?.pdfConfig?.customWidgets || [];

            customWidgets.forEach(widget => {
                if (!widget.groupBy) return;
                const aggregation = data.reduce((acc, rawClaim) => {
                    const key = getVal(rawClaim, widget.groupBy) || 'Unspecified';
                    if (!acc[key]) {
                        acc[key] = (widget.metricType === 'count') ? 0 : { sum: 0, count: 0 };
                    }
                    if (widget.metricType === 'count') {
                        acc[key]++;
                    } else if (widget.metricType === 'sum' && widget.metricColumn) {
                        const value = parseFloat(getVal(rawClaim, widget.metricColumn) || 0);
                        if (!isNaN(value)) {
                            acc[key].sum += value;
                            acc[key].count++;
                        }
                    }
                    return acc;
                }, {});
                
                const sorted = Object.entries(aggregation).sort(([, a], [, b]) => {
                    const valA = (widget.metricType === 'count') ? a : a.sum;
                    const valB = (widget.metricType === 'count') ? b : b.sum;
                    return valB - valA;
                });

                metrics[widget.id] = {
                    labels: sorted.map(item => item[0]),
                    data: sorted.map(item => (widget.metricType === 'count') ? item[1] : item[1].sum)
                };
            });

            return { claims, metrics };
        }
        
        function getPriorityScore(claim) {
            const totalCharges = parseFloat(getVal(claim.original, 'totalCharges') || 0);
            const age = parseInt(claim.age || 0);
            const status = (claim.status || '').toUpperCase();
            let score = 0;
            score += (totalCharges / 500);
            score += (age * 1.5);
            if (status === 'DENY') score += 100;
            return Math.round(score);
        }

        function renderDashboard(claims, metrics) {
            const fNum = (num) => num.toLocaleString('en-US');
            const fCur = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
            document.getElementById('executive-summary-cards').innerHTML = `<div class="col-md-6 col-lg-4 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #0d6efd;"><div class="metric-label">TOTAL CLAIMS</div><div class="metric-value">${fNum(metrics.totalClaims)}</div></div></div><div class="col-md-6 col-lg-4 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #198754;"><div class="metric-label">TOTAL NET PAYMENT (PENDING)</div><div class="metric-value">${fCur(metrics.totalNetPayment)}</div></div></div><div class="col-md-6 col-lg-4 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #ffc107;"><div class="metric-label">CLAIMS PEND STATUS</div><div class="metric-value">${fNum(metrics.claimsPend)}</div></div></div><div class="col-md-6 col-lg-4 mb-4"><div class="card dashboard-card h-100" style="border-left-color: #dc3545;"><div class="metric-label">CLAIMS DENIED</div><div class="metric-value">${fNum(metrics.claimsDenied)}</div></div></div>`;
            Object.values(myCharts).forEach(chart => chart.destroy());
            populateTeamDownloadButtons(claims);
        }

        function populateCategoryFilter(claims) {
            const filter = document.getElementById('categoryFilter');
            const categories = [...new Set(claims.filter(c => c.isActionable).map(c => c.category))];
            filter.innerHTML = '<option value="all" selected>All Actionable Categories</option>';
            categories.sort().forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                filter.appendChild(option);
            });
        }

        function renderWorkQueue(claims) {
            const selectedCategory = document.getElementById('categoryFilter').value;
            let actionable = claims.filter(c => c.isActionable);
            if (selectedCategory !== 'all') {
                actionable = actionable.filter(c => c.category === selectedCategory);
            }
            actionable.sort((a, b) => {
                const valA = a[currentSort.column];
                const valB = b[currentSort.column];
                let comp = 0;
                if(typeof valA === 'number' && typeof valB === 'number') {
                    comp = valA - valB;
                } else {
                    comp = (valA || '').toString().localeCompare((valB || '').toString());
                }
                return currentSort.direction === 'asc' ? comp : -comp;
            });
            document.getElementById('work-queue-body').innerHTML = actionable.map(claim =>
                `<tr>
                    <td>${claim.priorityScore}</td>
                    <td>${claim.category || 'N/A'}</td>
                    <td>${claim.source || 'N/A'}</td>
                    <td>${claim.teamName || 'N/A'}</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>${claim.claimId || 'N/A'}</td>
                    <td>${claim.age || 0}</td>
                    <td>$${(claim.netPayment || 0).toFixed(2)}</td>
                    <td>${claim.providerName || 'N/A'}</td>
                </tr>`
            ).join('');
        }

        function populateTeamDownloadButtons(claims) {
            const container = document.getElementById('teamReportButtons');
            const actionableClaims = claims.filter(c => c.isActionable && c.teamName);
            const teams = [...new Set(actionableClaims.map(c => c.teamName))];
            container.innerHTML = '';
            if (teams.length === 0) {
                container.innerHTML = '<p class="text-muted">No actionable claims found for any team.</p>';
                return;
            }
            teams.sort().forEach(teamName => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-success';
                btn.innerHTML = `<i class="bi bi-download"></i> Download ${teamName} Report`;
                btn.onclick = () => downloadTeamReport(teamName, actionableClaims);
                container.appendChild(btn);
            });
        }

        function downloadTeamReport(teamName, allActionableClaims) {
            const teamClaims = allActionableClaims.filter(c => c.teamName === teamName);
            if (teamClaims.length === 0) {
                alert(`No claims found for team: ${teamName}`);
                return;
            }

            const claimsByCategory = teamClaims.reduce((acc, claim) => {
                const category = claim.category;
                if (!acc[category]) acc[category] = [];
                acc[category].push(claim);
                return acc;
            }, {});

            const wb = XLSX.utils.book_new();
            const today = new Date().toISOString().slice(0, 10);

            Object.keys(claimsByCategory).sort().forEach(categoryName => {
                const claimsInCat = claimsByCategory[categoryName];
                let reportData;
                let ws;

                switch (categoryName) {
                    case 'Contract Issues': case 'Pay To': case 'W9 Research': case 'SEQ_TFL': {
                        const providerMap = new Map();
                        claimsInCat.forEach(claim => {
                            const providerName = getVal(claim.original, 'providerName') || 'Unknown';
                            const providerTin = getVal(claim.original, 'billingProviderTaxId') || 'Unknown';
                            const networkStatus = getVal(claim.original, 'networkStatus') || 'Unknown';
                            const key = `${providerName}|${providerTin}|${networkStatus}`;
                            if (!providerMap.has(key)) {
                                providerMap.set(key, { 'Billing Provider Name': providerName, 'Billing Provider Tax ID': providerTin, 'Network Status': networkStatus, 'Count of Claims': 0 });
                            }
                            providerMap.get(key)['Count of Claims']++;
                        });
                        reportData = Array.from(providerMap.values());
                        reportData.sort((a, b) => b['Count of Claims'] - a['Count of Claims']);
                        reportData.forEach(row => { row['Prov Ops Team Mbr'] = ''; row['PV Updated (Y/N)'] = ''; row['Notes'] = ''; });
                        ws = XLSX.utils.json_to_sheet(reportData);
                        break;
                    }

                    case 'Rendering Provider': {
                        const renderingMap = new Map();
                        claimsInCat.forEach(claim => {
                            const renderingName = getVal(claim.original, 'renderingProviderName') || 'Unknown';
                            const renderingNpi = getVal(claim.original, 'renderingProviderNpi') || 'Unknown';
                            const billingTin = getVal(claim.original, 'billingProviderTaxId') || 'Unknown';
                            const networkStatus = getVal(claim.original, 'networkStatus') || 'Unknown';
                            const key = `${renderingName}|${renderingNpi}|${billingTin}|${networkStatus}`;
                            if (!renderingMap.has(key)) {
                                renderingMap.set(key, { 'Rendering Provider Name': renderingName, 'Rendering Provider NPI': renderingNpi, 'Billing Provider TIN': billingTin, 'Network Status': networkStatus });
                            }
                        });
                        reportData = Array.from(renderingMap.values());
                        reportData.sort((a, b) => a['Rendering Provider Name'].localeCompare(b['Rendering Provider Name']));
                        reportData.forEach(row => { row['Prov Ops Team Mbr'] = ''; row['PV Updated (Y/N)'] = ''; row['Notes'] = ''; });
                         ws = XLSX.utils.json_to_sheet(reportData);
                        break;
                    }

                    default: {
                        reportData = claimsInCat.map(claim => ({ ...claim.original, 'Priority Score': claim.priorityScore, 'Assigned Team': claim.teamName, 'Category': claim.category, 'Categorization Source': claim.source, 'Prov Ops Team Mbr': '', 'PV Updated (Y/N)': '', 'Notes': '' }));
                        ws = XLSX.utils.json_to_sheet(reportData);
                        break;
                    }
                }
                
                const safeSheetName = categoryName.replace(/[\/\\?*\[\]]/g, '').substring(0, 31);
                XLSX.utils.book_append_sheet(wb, ws, safeSheetName);
            });

            const clientName = document.getElementById('clientName').value.trim().replace(/ /g, '_') || 'Client';
            const safeTeamName = teamName.replace(/ /g, '_');
            const fileName = `${clientName}_${safeTeamName}_Report_${today}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }
        
        async function generateStructuredPDF() {
            if (Object.keys(aggregatedMetrics).length === 0) { alert("Please load data first."); return; }
            const clientName = document.getElementById('clientName').value.trim();
            const selectedConfigId = parseInt(document.getElementById('configSelector').value, 10);
            const config = allConfigs.find(c => c.id === selectedConfigId);

            if (!config) { alert("Please select a valid report configuration."); return; }
            const pdfConfig = config.config_data.pdfConfig;
            if (!pdfConfig || !pdfConfig.sections || pdfConfig.sections.length === 0) {
                alert("The selected configuration does not have a PDF layout defined. Please configure it in the Admin Console.");
                return;
            }

            const today = new Date();
            const formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            
            const pdfTitle = (pdfConfig.reportTitle || '{clientName} Daily Summary Report {date}')
                .replace('{clientName}', clientName)
                .replace('{date}', formattedDate);
                
            const fileName = `${clientName.replace(/ /g, '_')}_Daily_Summary_Report_${formattedDate}.pdf`;

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'pt', 'a4');
            const margin = 40;
            const pageContentWidth = pdf.internal.pageSize.getWidth() - (margin * 2);
            let currentY = margin;

            // --- PDF HELPER FUNCTIONS ---
            const checkPageBreak = (spaceNeeded) => {
                if (currentY + spaceNeeded > pdf.internal.pageSize.getHeight() - margin) {
                    pdf.addPage();
                    currentY = margin;
                }
            };
            const addMainTitle = (title) => {
                pdf.setFont('helvetica', 'bold');
                pdf.setFontSize(22);
                pdf.text(title, pdf.internal.pageSize.getWidth() / 2, currentY, { align: 'center' });
                currentY += 40;
            };
            const addSectionHeader = (title) => {
                checkPageBreak(40);
                pdf.setFont('helvetica', 'bold');
                pdf.setFontSize(16);
                pdf.text(title, margin, currentY);
                currentY += 25;
            };
            const drawSummaryCards = (pdf, metrics, x, y, width) => {
                const fNum = (num) => num.toLocaleString('en-US');
                const fCur = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
                const cards = [
                    { label: 'TOTAL CLAIMS', value: fNum(metrics.totalClaims), color: '#0d6efd'},
                    { label: 'TOTAL NET PAYMENT (PENDING)', value: fCur(metrics.totalNetPayment), color: '#198754'},
                    { label: 'CLAIMS PEND STATUS', value: fNum(metrics.claimsPend), color: '#ffc107'},
                    { label: 'CLAIMS DENIED', value: fNum(metrics.claimsDenied), color: '#dc3545'}
                ];
                
                const cardsPerRow = 2;
                const cardHeight = 60;
                const gap = 20;
                const cardWidth = (width - gap) / cardsPerRow;
                let currentX = x;

                cards.forEach((card, index) => {
                    if (index > 0 && index % cardsPerRow === 0) {
                        y += cardHeight + gap;
                        currentX = x;
                    }
                    
                    pdf.setDrawColor('#dee2e6');
                    pdf.setLineWidth(1);
                    pdf.rect(currentX, y, cardWidth, cardHeight);
                    
                    pdf.setFillColor(card.color);
                    pdf.rect(currentX, y, 4, cardHeight, 'F');
                    
                    const textX = currentX + 15;
                    pdf.setFont('helvetica', 'bold');
                    pdf.setFontSize(8);
                    pdf.setTextColor('#6c757d');
                    pdf.text(card.label, textX, y + 20);
                    
                    pdf.setFontSize(22);
                    pdf.setTextColor('#212529');
                    pdf.text(card.value, textX, y + 45);
                    
                    currentX += cardWidth + gap;
                });
                return y + cardHeight + 20;
            };
            const prepareTableData = (dataSourceId) => {
                const sourceData = aggregatedMetrics[dataSourceId];
                if (!sourceData || !sourceData.labels || !sourceData.data) return [];
                return sourceData.labels.map((label, index) => ({
                    label: label,
                    data: sourceData.data[index]
                }));
            };

            // --- RENDER PDF HEADER ---
            const logoImg = document.getElementById('logoImage');
            // --- FIX: Pass the image ELEMENT, not the .src string ---
            pdf.addImage(logoImg, 'PNG', margin, currentY, 84, 24);
            currentY += 40;
            addMainTitle(pdfTitle);

            // --- RENDER DYNAMIC SECTIONS ---
            for (const section of pdfConfig.sections) {
                addSectionHeader(section.title);
                
                switch (section.type) {
                    case 'summary': {
                        currentY = drawSummaryCards(pdf, aggregatedMetrics, margin, currentY, pageContentWidth);
                        break;
                    }
                    case 'table':
                    case 'custom_table': {
                        const tableData = prepareTableData(section.id);
                        const allWidgets = [
                            ...pdfConfig.customWidgets, 
                            { id: 'claimsByFinalStatus', columns: [{ header: 'Status', dataKey: 'label'}, {header: 'Count', dataKey: 'data'}]}, 
                            { id: 'claimsByWorkflowState', columns: [{ header: 'State', dataKey: 'label'}, {header: 'Count', dataKey: 'data'}]}, 
                            { id: 'topEdits', columns: [{ header: 'Edit', dataKey: 'label'}, {header: 'Count', dataKey: 'data'}]}, 
                            { id: 'topProvidersOverall', columns: [{ header: 'Provider', dataKey: 'label'}, {header: 'Count', dataKey: 'data'}]} 
                        ];
                        const widgetDefinition = allWidgets.find(w => w.id === section.id);
                        
                        if (widgetDefinition && tableData.length > 0) {
                            const columns = widgetDefinition.columns;
                            const head = [columns.map(c => c.header)];
                            const body = tableData.map(row => columns.map(col => {
                                let val = row[col.dataKey];
                                if (typeof val === 'number') {
                                    if (widgetDefinition.metricType === 'sum') {
                                        return val.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
                                    }
                                    return val.toLocaleString();
                                }
                                return val;
                            }));
                            
                            pdf.autoTable({ startY: currentY, head, body, theme: 'striped', headStyles: { fillColor: [70, 90, 108] } });
                            currentY = pdf.previousAutoTable.finalY + 20;
                        } else {
                            pdf.setFont('helvetica', 'normal');
                            pdf.setFontSize(10);
                            pdf.text('No data available for this section.', margin, currentY);
                            currentY += 20;
                        }
                        break;
                    }
                    case 'aging_table': {
                        const agingData = aggregatedMetrics[section.id];
                        if (agingData) {
                            const head = [['Aging', 'Par', 'Non Par', 'Grand Total']];
                            const body = [];
                            const bins = ['0-20', '21-27', '28-30', '31-59', '60+'];
                            bins.forEach(bin => {
                                const binData = agingData.bins[bin];
                                body.push([bin, binData.par.toLocaleString(), binData.nonpar.toLocaleString(), binData.total.toLocaleString()]);
                            });
                            const percData = agingData.bins['60+ Percent'];
                            body.push(['60+ Percentage', percData.par, percData.nonpar, percData.total]);
                            body.push(['Grand Total', agingData.totals.par.toLocaleString(), agingData.totals.nonpar.toLocaleString(), agingData.totals.grand.toLocaleString()]);

                            pdf.autoTable({
                                startY: currentY,
                                head: head,
                                body: body,
                                theme: 'striped',
                                headStyles: { fillColor: [70, 90, 108] },
                                didParseCell: (data) => {
                                    if (data.row.raw[0] === '60+ Percentage' || data.row.raw[0] === 'Grand Total') {
                                        data.cell.styles.fontStyle = 'bold';
                                    }
                                }
                            });
                            currentY = pdf.previousAutoTable.finalY + 20;
                        } else {
                            pdf.setFont('helvetica', 'normal');
                            pdf.setFontSize(10);
                            pdf.text('No aging data available.', margin, currentY);
                            currentY += 20;
                        }
                        break;
                    }
                }
            }
            
            pdf.save(fileName);
        }

    </script>
</body>
</html>```
